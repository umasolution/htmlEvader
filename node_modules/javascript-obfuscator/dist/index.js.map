{"version":3,"sources":["webpack:///webpack/bootstrap 8167c31134c3dec31eff","webpack:///external \"inversify\"","webpack:///./src/container/ServiceIdentifiers.ts","webpack:///external \"tslib\"","webpack:///./src/node/NodeGuards.ts","webpack:///./src/node/NodeUtils.ts","webpack:///./src/decorators/Initializable.ts","webpack:///./src/enums/node-transformers/TransformationStage.ts","webpack:///./src/node-transformers/AbstractNodeTransformer.ts","webpack:///./src/custom-nodes/AbstractCustomNode.ts","webpack:///./src/node/Nodes.ts","webpack:///external \"estraverse\"","webpack:///./src/enums/node/NodeType.ts","webpack:///external \"string-template\"","webpack:///./src/enums/custom-nodes/ControlFlowCustomNode.ts","webpack:///./src/enums/ObfuscationTarget.ts","webpack:///./src/container/InversifyContainerFacade.ts","webpack:///./src/node/NodeAppender.ts","webpack:///./src/enums/event-emitters/ObfuscationEvent.ts","webpack:///./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer.ts","webpack:///./src/JavaScriptObfuscatorFacade.ts","webpack:///./src/enums/node-transformers/NodeTransformer.ts","webpack:///./src/enums/custom-nodes/CustomNode.ts","webpack:///./src/utils/Utils.ts","webpack:///./src/custom-nodes/AbstractCustomNodeGroup.ts","webpack:///./src/enums/generators/identifier-names-generators/IdentifierNamesGenerator.ts","webpack:///./src/enums/source-map/SourceMapMode.ts","webpack:///./src/enums/StringArrayEncoding.ts","webpack:///./src/options/presets/NoCustomNodes.ts","webpack:///./src/node-transformers/obfuscating-transformers/obfuscating-replacers/AbstractObfuscatingReplacer.ts","webpack:///./src/analyzers/stack-trace-analyzer/callee-data-extractors/AbstractCalleeDataExtractor.ts","webpack:///external \"escodegen-wallaby\"","webpack:///./src/node-transformers/control-flow-transformers/control-flow-replacers/AbstractControlFlowReplacer.ts","webpack:///./src/templates/GlobalVariableNoEvalTemplate.ts","webpack:///./src/options/presets/Default.ts","webpack:///./src/cli/JavaScriptObfuscatorCLI.ts","webpack:///external \"path\"","webpack:///./src/enums/analyzers/stack-trace-analyzer/CalleeDataExtractor.ts","webpack:///external \"esprima\"","webpack:///./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer.ts","webpack:///./src/node-transformers/control-flow-transformers/control-flow-replacers/ExpressionWithOperatorControlFlowReplacer.ts","webpack:///./src/enums/custom-nodes/DeadCodeInjectionCustomNode.ts","webpack:///./src/enums/custom-nodes/CustomNodeGroup.ts","webpack:///./src/generators/identifier-names-generators/AbstractIdentifierNamesGenerator.ts","webpack:///./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer.ts","webpack:///./src/enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard.ts","webpack:///./src/storages/MapStorage.ts","webpack:///./src/utils/RandomGenerator.ts","webpack:///external \"pjson\"","webpack:///external \"chalk\"","webpack:///external \"fs\"","webpack:///./index.ts","webpack:///external \"reflect-metadata\"","webpack:///./src/container/modules/analyzers/AnalyzersModule.ts","webpack:///./src/analyzers/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor.ts","webpack:///./src/analyzers/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor.ts","webpack:///./src/analyzers/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor.ts","webpack:///./src/analyzers/stack-trace-analyzer/StackTraceAnalyzer.ts","webpack:///./src/container/modules/node-transformers/ControlFlowTransformersModule.ts","webpack:///./src/node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer.ts","webpack:///./src/node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer.ts","webpack:///./src/node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer.ts","webpack:///./src/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.ts","webpack:///./src/node-transformers/control-flow-transformers/FunctionControlFlowTransformer.ts","webpack:///./src/node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer.ts","webpack:///./src/node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer.ts","webpack:///./src/container/modules/node-transformers/ConvertingTransformersModule.ts","webpack:///./src/node-transformers/converting-transformers/MemberExpressionTransformer.ts","webpack:///./src/node-transformers/converting-transformers/MethodDefinitionTransformer.ts","webpack:///./src/node-transformers/converting-transformers/ObjectExpressionKeysTransformer.ts","webpack:///./src/node-transformers/converting-transformers/TemplateLiteralTransformer.ts","webpack:///./src/container/modules/custom-nodes/CustomNodesModule.ts","webpack:///./src/custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup.ts","webpack:///./src/custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup.ts","webpack:///./src/custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup.ts","webpack:///./src/custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup.ts","webpack:///./src/custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode.ts","webpack:///./src/templates/GlobalVariableTemplate1.ts","webpack:///./src/templates/GlobalVariableTemplate2.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode.ts","webpack:///./src/custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode.ts","webpack:///./src/custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode.ts","webpack:///./src/templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate.ts","webpack:///./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode.ts","webpack:///./src/templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate.ts","webpack:///./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode.ts","webpack:///./src/templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate.ts","webpack:///./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode.ts","webpack:///./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate.ts","webpack:///./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval.ts","webpack:///./src/templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate.ts","webpack:///./src/custom-nodes/domain-lock-nodes/DomainLockNode.ts","webpack:///./src/templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode.ts","webpack:///./src/custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode.ts","webpack:///./src/templates/SingleNodeCallControllerTemplate.ts","webpack:///./src/custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode.ts","webpack:///./src/templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate.ts","webpack:///./src/custom-nodes/string-array-nodes/StringArrayCallsWrapper.ts","webpack:///./src/templates/AtobTemplate.ts","webpack:///./src/templates/Rc4Template.ts","webpack:///./src/templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate.ts","webpack:///./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate.ts","webpack:///./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate.ts","webpack:///./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate.ts","webpack:///./src/custom-nodes/string-array-nodes/StringArrayNode.ts","webpack:///./src/templates/string-array-nodes/string-array-node/StringArrayTemplate.ts","webpack:///./src/custom-nodes/string-array-nodes/StringArrayRotateFunctionNode.ts","webpack:///./src/templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate.ts","webpack:///./src/templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate.ts","webpack:///./src/enums/JSFuck.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode.ts","webpack:///./src/custom-nodes/control-flow-flattening-nodes/StringLiteralNode.ts","webpack:///./src/container/modules/node-transformers/FinalizingTransformersModule.ts","webpack:///./src/container/modules/generators/GeneratorsModule.ts","webpack:///./src/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.ts","webpack:///./src/generators/identifier-names-generators/MangledIdentifierNamesGenerator.ts","webpack:///./src/container/modules/node-transformers/NodeTransformersModule.ts","webpack:///./src/container/modules/node-transformers/ObfuscatingTransformersModule.ts","webpack:///./src/node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer.ts","webpack:///./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer.ts","webpack:///./src/node-transformers/obfuscating-transformers/CatchClauseTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/ClassDeclarationTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/FunctionDeclarationTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/FunctionTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/LabeledStatementTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/LiteralTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer.ts","webpack:///./src/node-transformers/obfuscating-transformers/ObjectExpressionTransformer.ts","webpack:///./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer.ts","webpack:///./src/node-transformers/obfuscating-transformers/VariableDeclarationTransformer.ts","webpack:///./src/container/modules/options/OptionsModule.ts","webpack:///./src/options/Options.ts","webpack:///external \"class-validator\"","webpack:///./src/options/ValidationErrorsFormatter.ts","webpack:///./src/options/OptionsNormalizer.ts","webpack:///./src/options/normalizer-rules/ControlFlowFlatteningThresholdRule.ts","webpack:///./src/options/normalizer-rules/DeadCodeInjectionRule.ts","webpack:///./src/options/normalizer-rules/DeadCodeInjectionThresholdRule.ts","webpack:///./src/options/normalizer-rules/DomainLockRule.ts","webpack:///./src/options/normalizer-rules/SelfDefendingRule.ts","webpack:///./src/options/normalizer-rules/SourceMapBaseUrlRule.ts","webpack:///./src/options/normalizer-rules/SourceMapFileNameRule.ts","webpack:///./src/options/normalizer-rules/StringArrayRule.ts","webpack:///./src/options/normalizer-rules/StringArrayEncodingRule.ts","webpack:///./src/options/normalizer-rules/StringArrayThresholdRule.ts","webpack:///./src/container/modules/node-transformers/PreparingTransformersModule.ts","webpack:///./src/node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard.ts","webpack:///./src/node-transformers/preparing-transformers/CommentsTransformer.ts","webpack:///./src/node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard.ts","webpack:///./src/node-transformers/preparing-transformers/CustomNodesTransformer.ts","webpack:///./src/node-transformers/preparing-transformers/EvaCallExpressionTransformer.ts","webpack:///external \"js-string-escape\"","webpack:///./src/node-transformers/preparing-transformers/ObfuscatingGuardsTransformer.ts","webpack:///./src/node-transformers/preparing-transformers/ParentificationTransformer.ts","webpack:///./src/container/modules/storages/StoragesModule.ts","webpack:///./src/storages/control-flow/ControlFlowStorage.ts","webpack:///./src/storages/custom-node-group/CustomNodeGroupStorage.ts","webpack:///./src/storages/string-array/StringArrayStorage.ts","webpack:///./src/storages/ArrayStorage.ts","webpack:///./src/container/modules/utils/UtilsModule.ts","webpack:///./src/utils/ArrayUtils.ts","webpack:///./src/utils/CryptUtils.ts","webpack:///external \"md5\"","webpack:///external \"chance\"","webpack:///./src/utils/EscapeSequenceEncoder.ts","webpack:///./src/JavaScriptObfuscator.ts","webpack:///./src/enums/logger/LoggingMessage.ts","webpack:///./src/EsprimaFacade.ts","webpack:///./src/logger/Logger.ts","webpack:///./src/event-emitters/ObfuscationEventEmitter.ts","webpack:///external \"events\"","webpack:///./src/ObfuscationResult.ts","webpack:///./src/SourceCode.ts","webpack:///./src/source-map/SourceMapCorrector.ts","webpack:///./src/node-transformers/TransformersRunner.ts","webpack:///./src/enums/node-transformers/VisitorDirection.ts","webpack:///external \"commander\"","webpack:///./src/cli/sanitizers/ArraySanitizer.ts","webpack:///./src/cli/sanitizers/BooleanSanitizer.ts","webpack:///./src/cli/sanitizers/IdentifierNamesGeneratorSanitizer.ts","webpack:///./src/cli/sanitizers/ObfuscatingTargetSanitizer.ts","webpack:///./src/cli/sanitizers/SourceMapModeSanitizer.ts","webpack:///./src/cli/sanitizers/StringArrayEncodingSanitizer.ts","webpack:///./src/cli/utils/CLIUtils.ts","webpack:///external \"mkdirp\"","webpack:///./src/cli/utils","webpack:///./src/cli/utils/SourceCodeReader.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 50);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8167c31134c3dec31eff","module.exports = require(\"inversify\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"inversify\"\n// module id = 0\n// module chunks = 0","export enum ServiceIdentifiers {\n    Factory__ICalleeDataExtractor = 'Factory<ICalleeDataExtractor>',\n    Factory__IControlFlowCustomNode = 'Factory<IControlFlowCustomNode>',\n    Factory__IControlFlowReplacer = 'Factory<IControlFlowReplacer>',\n    Factory__ICustomNode = 'Factory<ICustomNode>',\n    Factory__ICustomNodeGroup = 'Factory<ICustomNodeGroup>',\n    Factory__IDeadCodeInjectionCustomNode = 'Factory<IDeadCodeInjectionCustomNode>',\n    Factory__IIdentifierNamesGenerator = 'Factory<IIdentifierNamesGenerator>',\n    Factory__IIdentifierObfuscatingReplacer = 'Factory<IIdentifierObfuscatingReplacer>',\n    Factory__INodeGuard = 'Factory<INodeGuard>',\n    Factory__INodeTransformer = 'Factory<INodeTransformer[]>',\n    Factory__IObfuscationResult = 'Factory<IObfuscationResult>',\n    Factory__IObfuscatingReplacer = 'Factory<IObfuscatingReplacer>',\n    Factory__TControlFlowStorage = 'Factory<TControlFlowStorage>',\n    IArrayUtils = 'IArrayUtils',\n    ICalleeDataExtractor = 'ICalleeDataExtractor',\n    ICryptUtils = 'ICryptUtils',\n    ICustomNode = 'ICustomNode',\n    ICustomNodeGroup = 'ICustomNodeGroup',\n    IControlFlowReplacer = 'IControlFlowReplacer',\n    IEscapeSequenceEncoder = 'IEscapeSequenceEncoder',\n    IIdentifierNamesGenerator = 'IIdentifierNamesGenerator',\n    IIdentifierObfuscatingReplacer = 'IIdentifierObfuscatingReplacer',\n    IJavaScriptObfuscator = 'IJavaScriptObfuscator',\n    ILogger = 'ILogger',\n    INodeGuard = 'INodeGuard',\n    INodeTransformer = 'INodeTransformer',\n    IObfuscationEventEmitter = 'IObfuscationEventEmitter',\n    IObfuscationResult = 'IObfuscationResult',\n    IOptions = 'IOptions',\n    IOptionsNormalizer = 'IOptionsNormalizer',\n    IObfuscatingReplacer = 'IObfuscatingReplacer',\n    IRandomGenerator = 'IRandomGenerator',\n    ISourceCode = 'ISourceCode',\n    ISourceMapCorrector = 'ISourceMapCorrector',\n    IStackTraceAnalyzer = 'IStackTraceAnalyzer',\n    ITransformersRunner = 'ITransformersRunner',\n    Newable__ICustomNode = 'Newable<ICustomNode>',\n    Newable__TControlFlowStorage = 'Newable<TControlFlowStorage>',\n    TCustomNodeGroupStorage = 'TCustomNodeGroupStorage',\n    TInputOptions = 'TInputOptions',\n    TStringArrayStorage = 'TStringArrayStorage'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/container/ServiceIdentifiers.ts","module.exports = require(\"tslib\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"tslib\"\n// module id = 2\n// module chunks = 0","import * as ESTree from 'estree';\n\nimport { TNodeWithBlockScope } from '../types/node/TNodeWithBlockScope';\nimport { TNodeWithScope } from '../types/node/TNodeWithScope';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeGuards {\n    /**\n     * @type {string[]}\n     */\n    private static readonly nodesWithBlockScope: string[] = [\n        NodeType.ArrowFunctionExpression,\n        NodeType.FunctionDeclaration,\n        NodeType.FunctionExpression,\n        NodeType.MethodDefinition,\n    ];\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrayPatternNode (node: ESTree.Node): node is ESTree.ArrayPattern {\n        return node.type === NodeType.ArrayPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrowFunctionExpressionNode (node: ESTree.Node): node is ESTree.ArrowFunctionExpression {\n        return node.type === NodeType.ArrowFunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAssignmentPatternNode (node: ESTree.Node): node is ESTree.AssignmentPattern {\n        return node.type === NodeType.AssignmentPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAwaitExpressionNode (node: ESTree.Node): node is ESTree.AwaitExpression {\n        return node.type === NodeType.AwaitExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBlockStatementNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return node.type === NodeType.BlockStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBreakStatementNode (node: ESTree.Node): node is ESTree.BreakStatement {\n        return node.type === NodeType.BreakStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCallExpressionNode (node: ESTree.Node): node is ESTree.CallExpression {\n        return node.type === NodeType.CallExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCatchClauseNode (node: ESTree.Node): node is ESTree.CatchClause {\n        return node.type === NodeType.CatchClause;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isClassDeclarationNode (node: ESTree.Node): node is ESTree.ClassDeclaration {\n        return node.type === NodeType.ClassDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isContinueStatementNode (node: ESTree.Node): node is ESTree.ContinueStatement {\n        return node.type === NodeType.ContinueStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExpressionStatementNode (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionDeclarationNode (node: ESTree.Node): node is ESTree.FunctionDeclaration {\n        return node.type === NodeType.FunctionDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionExpressionNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return node.type === NodeType.FunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIdentifierNode (node: ESTree.Node): node is ESTree.Identifier {\n        return node.type === NodeType.Identifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIfStatementNode (node: ESTree.Node): node is ESTree.IfStatement {\n        return node.type === NodeType.IfStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isLabelIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        const parentNodeIsLabeledStatementNode: boolean = NodeGuards.isLabeledStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsContinueStatementNode: boolean = NodeGuards.isContinueStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsBreakStatementNode: boolean = NodeGuards.isBreakStatementNode(parentNode) && parentNode.label === node;\n\n        return parentNodeIsLabeledStatementNode || parentNodeIsContinueStatementNode || parentNodeIsBreakStatementNode;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLabeledStatementNode (node: ESTree.Node): node is ESTree.LabeledStatement {\n        return node.type === NodeType.LabeledStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLiteralNode (node: ESTree.Node): node is ESTree.Literal {\n        return node.type === NodeType.Literal;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMemberExpressionNode (node: ESTree.Node): node is ESTree.MemberExpression {\n        return node.type === NodeType.MemberExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMethodDefinitionNode (node: ESTree.Node): node is ESTree.MethodDefinition {\n        return node.type === NodeType.MethodDefinition;\n    }\n\n    /**\n     * @param {Object} object\n     * @returns {boolean}\n     */\n    public static isNode (object: Object & { type?: string }): object is ESTree.Node {\n        return object && !object.type !== undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isNodeHasBlockScope (node: ESTree.Node, parentNode: ESTree.Node): node is TNodeWithBlockScope {\n        return NodeGuards.isProgramNode(node) || (\n            NodeGuards.isBlockStatementNode(node)\n            && NodeGuards.nodesWithBlockScope.includes(parentNode.type)\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeHasScope (node: ESTree.Node): node is TNodeWithScope {\n        return NodeGuards.isProgramNode(node)\n            || NodeGuards.isBlockStatementNode(node)\n            || NodeGuards.isSwitchCaseNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithComments (node: ESTree.Node): node is ESTree.Node {\n        return Boolean(node.leadingComments) || Boolean(node.trailingComments);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectPatternNode (node: ESTree.Node): node is ESTree.ObjectPattern {\n        return node.type === NodeType.ObjectPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectExpressionNode (node: ESTree.Node): node is ESTree.ObjectExpression {\n        return node.type === NodeType.ObjectExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isProgramNode (node: ESTree.Node): node is ESTree.Program {\n        return node.type === NodeType.Program;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isPropertyNode (node: ESTree.Node): node is ESTree.Property {\n        return node.type === NodeType.Property;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isReplaceableIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        if (!NodeGuards.isIdentifierNode(node)) {\n            return false;\n        }\n\n        const parentNodeIsPropertyNode: boolean = NodeGuards.isPropertyNode(parentNode) &&\n            !parentNode.computed &&\n            parentNode.key === node;\n        const parentNodeIsMemberExpressionNode: boolean = (\n            NodeGuards.isMemberExpressionNode(parentNode) &&\n            !parentNode.computed &&\n            parentNode.property === node\n        );\n        const parentNodeIsMethodDefinitionNode: boolean = NodeGuards.isMethodDefinitionNode(parentNode) &&\n            !parentNode.computed;\n        const isLabelIdentifierNode: boolean = NodeGuards.isLabelIdentifierNode(node, parentNode);\n\n        return !parentNodeIsPropertyNode &&\n            !parentNodeIsMemberExpressionNode &&\n            !parentNodeIsMethodDefinitionNode &&\n            !isLabelIdentifierNode;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isRestElementNode (node: ESTree.Node): node is ESTree.RestElement {\n        return node.type === NodeType.RestElement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isReturnStatementNode (node: ESTree.Node): node is ESTree.ReturnStatement {\n        return node.type === NodeType.ReturnStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSuperNode (node: ESTree.Node): node is ESTree.Super {\n        return node.type === NodeType.Super;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSwitchCaseNode (node: ESTree.Node): node is ESTree.SwitchCase {\n        return node.type === NodeType.SwitchCase;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTemplateLiteralNode (node: ESTree.Node): node is ESTree.TemplateLiteral {\n        return node.type === NodeType.TemplateLiteral;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUnaryExpressionNode (node: ESTree.Node): node is ESTree.UnaryExpression {\n        return node.type === NodeType.UnaryExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUseStrictOperator (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement && node.directive === 'use strict';\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclarationNode (node: ESTree.Node): node is ESTree.VariableDeclaration {\n        return node.type === NodeType.VariableDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclaratorNode (node: ESTree.Node): node is ESTree.VariableDeclarator {\n        return node.type === NodeType.VariableDeclarator;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isWhileStatementNode (node: ESTree.Node): node is ESTree.WhileStatement {\n        return node.type === NodeType.WhileStatement;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node/NodeGuards.ts","import * as escodegen from 'escodegen-wallaby';\nimport * as esprima from 'esprima';\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeWithBlockScope } from '../types/node/TNodeWithBlockScope';\nimport { TNodeWithScope } from '../types/node/TNodeWithScope';\nimport { TObject } from '../types/TObject';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeUtils {\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static addXVerbatimPropertyToLiterals <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        estraverse.replace(astTree, {\n            leave: (node: ESTree.Node) => {\n                if (NodeGuards.isLiteralNode(node)) {\n                    node['x-verbatim-property'] = {\n                        content: node.raw,\n                        precedence: escodegen.Precedence.Primary\n                    };\n                }\n            }\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static clone <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        return NodeUtils.parentize(NodeUtils.cloneRecursive(astTree));\n    }\n\n    /**\n     * @param {string} code\n     * @returns {TStatement[]}\n     */\n    public static convertCodeToStructure (code: string): TStatement[] {\n        let structure: ESTree.Program = esprima.parseScript(code);\n\n        structure = NodeUtils.addXVerbatimPropertyToLiterals(structure);\n        structure = NodeUtils.parentize(structure);\n\n        return structure.body;\n    }\n\n    /**\n     * @param {NodeGuards[]} structure\n     * @returns {string}\n     */\n    public static convertStructureToCode (structure: ESTree.Node[]): string {\n        return structure.reduce((code: string, node: ESTree.Node) => {\n            return code + escodegen.generate(node, {\n                sourceMapWithCode: true\n            }).code;\n        }, '');\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {TNodeWithBlockScope[]}\n     */\n    public static getBlockScopesOfNode (targetNode: ESTree.Node): TNodeWithBlockScope[] {\n        return NodeUtils.getBlockScopesOfNodeRecursive(targetNode);\n    }\n\n    /**\n     * @param {Statement} node\n     * @returns {TStatement | null}\n     */\n    public static getNextSiblingStatementNode (node: ESTree.Statement): TStatement | null {\n        return NodeUtils.getSiblingStatementNodeByOffset(node, 1);\n    }\n\n    /**\n     * @param {Statement} node\n     * @returns {TStatement | null}\n     */\n    public static getPreviousSiblingStatementNode (node: ESTree.Statement): TStatement | null {\n        return NodeUtils.getSiblingStatementNodeByOffset(node, -1);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {TNodeWithScope}\n     */\n    public static getScopeOfNode (node: ESTree.Node): TNodeWithScope {\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (!NodeGuards.isNodeHasScope(parentNode)) {\n            return NodeUtils.getScopeOfNode(parentNode);\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {UnaryExpression} unaryExpressionNode\n     * @returns {NodeGuards}\n     */\n    public static getUnaryExpressionArgumentNode (unaryExpressionNode: ESTree.UnaryExpression): ESTree.Node {\n        if (NodeGuards.isUnaryExpressionNode(unaryExpressionNode.argument)) {\n            return NodeUtils.getUnaryExpressionArgumentNode(unaryExpressionNode.argument);\n        }\n\n        return unaryExpressionNode.argument;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static parentize <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        estraverse.replace(astTree, {\n            enter: NodeUtils.parentizeNode\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {T} node\n     * @param {Node} parentNode\n     * @returns {T}\n     */\n    public static parentizeNode <T extends ESTree.Node = ESTree.Node> (node: T, parentNode: ESTree.Node | null): T {\n        node.parentNode = parentNode || node;\n        node.obfuscatedNode = false;\n\n        return node;\n    }\n\n    /**\n     * @param {T} node\n     * @returns {T}\n     */\n    private static cloneRecursive <T> (node: T): T {\n        if (node === null) {\n            return node;\n        }\n\n        const copy: TObject = {};\n\n        for (const property in node) {\n            if (!node.hasOwnProperty(property) || property === 'parentNode') {\n                continue;\n            }\n\n            const value: any = node[property];\n\n            let clonedValue: any | null;\n\n            if (value === null || value instanceof RegExp) {\n                clonedValue = value;\n            } else if (Array.isArray(value)) {\n                clonedValue = value.map(NodeUtils.cloneRecursive);\n            } else if (typeof value === 'object') {\n                clonedValue = NodeUtils.cloneRecursive(value);\n            } else {\n                clonedValue = value;\n            }\n\n            copy[property] = clonedValue;\n        }\n\n        return <T>copy;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {TNodeWithBlockScope[]} blockScopes\n     * @param {number} depth\n     * @returns {TNodeWithBlockScope[]}\n     */\n    private static getBlockScopesOfNodeRecursive (\n        node: ESTree.Node,\n        blockScopes: TNodeWithBlockScope[] = [],\n        depth: number = 0\n    ): TNodeWithBlockScope[] {\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        /**\n         * Stage 1: process root block statement node of the slice of AST-tree\n         */\n        if (NodeGuards.isBlockStatementNode(node) && parentNode === node) {\n            blockScopes.push(node);\n        }\n\n        /**\n         * Stage 2: process any other nodes\n         */\n        if (\n            /**\n             * we can add program node instantly\n             */\n            NodeGuards.isProgramNode(node) ||\n            /**\n             * we shouldn't add to the array input node that is node with block scope itself\n             * so, on depth 0 we will skip push to the array of block scopes\n             */\n            (depth && NodeGuards.isNodeHasBlockScope(node, parentNode))\n        ) {\n            blockScopes.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeUtils.getBlockScopesOfNodeRecursive(parentNode, blockScopes, ++depth);\n        }\n\n        return blockScopes;\n    }\n\n    /**\n     * @param {Statement} node\n     * @param {number} offset\n     * @returns {TStatement | null}\n     */\n    private static getSiblingStatementNodeByOffset (node: ESTree.Statement, offset: number): TStatement | null {\n        const scopeNode: TNodeWithScope = NodeUtils.getScopeOfNode(node);\n        const scopeBody: TStatement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(node);\n\n        return scopeBody[indexInScope + offset] || null;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node/NodeUtils.ts","/* tslint:disable:no-invalid-this */\n\nimport { IInitializable } from '../interfaces/IInitializable';\n\nconst defaultDescriptor: PropertyDescriptor = {\n    configurable: true,\n    enumerable: true\n};\nconst initializedTargetMetadataKey: string = '_initialized';\nconst initializablePropertiesSetMetadataKey: string = '_initializablePropertiesSet';\nconst wrappedMethodsSetMetadataKey: string = '_wrappedMethodsSet';\nconst constructorMethodName: string = 'constructor';\n\n/**\n * @param {string} initializeMethodName\n * @returns {(target: IInitializable, propertyKey: (string | symbol)) => any}\n */\nexport function initializable (\n    initializeMethodName: string = 'initialize'\n): (target: IInitializable, propertyKey: string | symbol) => any {\n    const decoratorName: string = Object.keys(this)[0];\n\n    return (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor => {\n        const initializeMethod: Function = target[initializeMethodName];\n\n        if (!initializeMethod || typeof initializeMethod !== 'function') {\n            throw new Error(`\\`${initializeMethodName}\\` method with initialization logic not ` +\n                `found. \\`@${decoratorName}\\` decorator requires \\`${initializeMethodName}\\` method`);\n        }\n\n        /**\n         * Stage #1: initialize target metadata\n         */\n        initializeTargetMetadata(initializedTargetMetadataKey, false, target);\n        initializeTargetMetadata(initializablePropertiesSetMetadataKey, new Set(), target);\n        initializeTargetMetadata(wrappedMethodsSetMetadataKey, new Set(), target);\n\n        /**\n         * Stage #2: wrap target methods\n         */\n        wrapTargetMethodsInInitializedCheck(target, initializeMethodName);\n        wrapInitializeMethodInInitializeCheck(target, initializeMethodName, propertyKey);\n\n        /**\n         * Stage #3: wrap target properties\n         */\n        return wrapInitializableProperty(target, propertyKey);\n    };\n}\n\n/**\n * @param {string} metadataKey\n * @param metadataValue\n * @param {IInitializable} target\n */\nfunction initializeTargetMetadata (metadataKey: string, metadataValue: any, target: IInitializable): void {\n    const hasInitializedMetadata: boolean = Reflect.hasMetadata(metadataKey, target);\n\n    if (!hasInitializedMetadata) {\n        Reflect.defineMetadata(metadataKey, metadataValue, target);\n    }\n}\n\n/**\n * Wraps all target methods with additional logic that check that this methods will called after `initialize` method\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n */\nfunction wrapTargetMethodsInInitializedCheck (target: IInitializable, initializeMethodName: string): void {\n    const ownPropertyNames: string[] = Object.getOwnPropertyNames(target);\n    const prohibitedPropertyNames: string[] = [initializeMethodName, constructorMethodName];\n\n    ownPropertyNames.forEach((propertyName: string) => {\n        const initializablePropertiesSet: Set <string | symbol> = Reflect\n            .getMetadata(initializablePropertiesSetMetadataKey, target);\n        const wrappedMethodsSet: Set <string | symbol> = Reflect\n            .getMetadata(wrappedMethodsSetMetadataKey, target);\n\n        const isProhibitedPropertyName: boolean = prohibitedPropertyNames.includes(propertyName)\n            || initializablePropertiesSet.has(propertyName)\n            || wrappedMethodsSet.has(propertyName);\n\n        if (isProhibitedPropertyName) {\n            return;\n        }\n\n        const targetProperty: any = target[propertyName];\n\n        if (typeof targetProperty !== 'function') {\n            return;\n        }\n\n        const methodDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, propertyName) || defaultDescriptor;\n        const originalMethod: Function = methodDescriptor.value;\n\n        Object.defineProperty(target, propertyName, {\n            ...methodDescriptor,\n            value: function (): void {\n                if (!Reflect.getMetadata(initializedTargetMetadataKey, this)) {\n                    throw new Error(`Class should be initialized with \\`${initializeMethodName}()\\` method`);\n                }\n\n                return originalMethod.apply(this, arguments);\n            }\n        });\n\n        wrappedMethodsSet.add(propertyName);\n    });\n}\n\n/**\n * Wraps `initialize` method with additional logic to check that `initialized` properties will set\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n * @param {string | symbol} propertyKey\n */\nfunction wrapInitializeMethodInInitializeCheck (\n    target: IInitializable,\n    initializeMethodName: string,\n    propertyKey: string | symbol\n): void {\n    const methodDescriptor: PropertyDescriptor = Object\n        .getOwnPropertyDescriptor(target, initializeMethodName) || defaultDescriptor;\n    const originalMethod: Function = methodDescriptor.value;\n\n    Object.defineProperty(target, initializeMethodName, {\n        ...methodDescriptor,\n        value: function (): void {\n            /**\n             * should define metadata before `initialize` method call,\n             * because of cases when other methods will called inside `initialize` method\n             */\n            Reflect.defineMetadata(initializedTargetMetadataKey, true, this);\n\n            const result: any = originalMethod.apply(this, arguments);\n\n            if (this[propertyKey]) {}\n\n            return result;\n        }\n    });\n}\n\n/**\n * Wraps initializable property in additional checks\n *\n * @param {IInitializable} target\n * @param {string | symbol} propertyKey\n * @returns {PropertyDescriptor}\n */\nfunction wrapInitializableProperty (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor {\n    const initializablePropertiesSet: Set <string | symbol> = Reflect\n        .getMetadata(initializablePropertiesSetMetadataKey, target);\n\n    initializablePropertiesSet.add(propertyKey);\n\n    const initializablePropertyMetadataKey: string = `_${propertyKey}`;\n    const propertyDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, initializablePropertyMetadataKey) || defaultDescriptor;\n\n    Object.defineProperty(target, propertyKey, {\n        ...propertyDescriptor,\n        get: function (): any {\n            if (this[initializablePropertyMetadataKey] === undefined) {\n                throw new Error(`Property \\`${propertyKey}\\` is not initialized! Initialize it first!`);\n            }\n\n            return this[initializablePropertyMetadataKey];\n        },\n        set: function (newVal: any): void {\n            this[initializablePropertyMetadataKey] = newVal;\n        }\n    });\n\n    return propertyDescriptor;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/decorators/Initializable.ts","export enum TransformationStage {\n    Preparing = 'Preparing',\n    DeadCodeInjection = 'DeadCodeInjection',\n    ControlFlowFlattening = 'ControlFlowFlattening',\n    Converting = 'Converting',\n    Obfuscating = 'Obfuscating',\n    Finalizing = 'Finalizing'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/node-transformers/TransformationStage.ts","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { INodeTransformer } from '../interfaces/node-transformers/INodeTransformer';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { initializable } from '../decorators/Initializable';\n\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\n\n@injectable()\nexport abstract class AbstractNodeTransformer implements INodeTransformer, IInitializable {\n    /**\n     * @type {number}\n     */\n    @initializable()\n    protected nodeIdentifier!: number;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.nodeIdentifier = this.randomGenerator.getRandomInteger(0, 10000);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public abstract getVisitor (transformationStage: TransformationStage): IVisitor | null;\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node | VisitorOption}\n     */\n    public abstract transformNode (node: ESTree.Node, parentNode: ESTree.Node): ESTree.Node | estraverse.VisitorOption;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/AbstractNodeTransformer.ts","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { GlobalVariableTemplate1 } from '../templates/GlobalVariableTemplate1';\nimport { GlobalVariableTemplate2 } from '../templates/GlobalVariableTemplate2';\n\n@injectable()\nexport abstract class AbstractCustomNode implements ICustomNode {\n    /**\n     * @type {string[]}\n     */\n    private static readonly globalVariableTemplateFunctions: string[] = [\n        GlobalVariableTemplate1(),\n        GlobalVariableTemplate2()\n    ];\n\n    /**\n     * @type {TStatement[] | null}\n     */\n    protected cachedNode: TStatement[] | null = null;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {any[]} args\n     */\n    public abstract initialize (...args: any[]): void;\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        if (!this.cachedNode) {\n            this.cachedNode = this.getNodeStructure();\n        }\n\n        return this.cachedNode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getGlobalVariableTemplate (): string {\n        return this.randomGenerator\n            .getRandomGenerator()\n            .pickone(AbstractCustomNode.globalVariableTemplateFunctions);\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected abstract getNodeStructure (): TStatement[];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/AbstractCustomNode.ts","import * as escodegen from 'escodegen-wallaby';\nimport * as ESTree from 'estree';\n\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class Nodes {\n    /**\n     * @param {TStatement[]} body\n     * @returns {Program}\n     */\n    public static getProgramNode (body: TStatement[] = []): ESTree.Program {\n        return {\n            type: NodeType.Program,\n            body,\n            sourceType: 'script',\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} elements\n     * @returns {ArrayExpression}\n     */\n    public static getArrayExpressionNode (\n        elements: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.ArrayExpression {\n        return {\n            type: NodeType.ArrayExpression,\n            elements\n        };\n    }\n\n    /**\n     * @param {AssignmentOperator} operator\n     * @param {Pattern | MemberExpression} left\n     * @param {Expression} right\n     * @returns {AssignmentExpression}\n     */\n    public static getAssignmentExpressionNode (\n        operator: ESTree.AssignmentOperator,\n        left: ESTree.Pattern | ESTree.MemberExpression,\n        right: ESTree.Expression\n    ): ESTree.AssignmentExpression {\n        return {\n            type: NodeType.AssignmentExpression,\n            operator,\n            left,\n            right,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {BinaryExpression}\n     */\n    public static getBinaryExpressionNode (\n        operator: ESTree.BinaryOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.BinaryExpression {\n        return {\n            type: NodeType.BinaryExpression,\n            operator,\n            left,\n            right,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {Statement[]} body\n     * @returns {BlockStatement}\n     */\n    public static getBlockStatementNode (body: ESTree.Statement[] = []): ESTree.BlockStatement {\n        return {\n            type: NodeType.BlockStatement,\n            body,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {BreakStatement}\n     */\n    public static getBreakStatement (label?: ESTree.Identifier): ESTree.BreakStatement {\n        const breakStatementNode: ESTree.BreakStatement = {\n            type: NodeType.BreakStatement,\n            obfuscatedNode: false\n        };\n\n        if (label) {\n            breakStatementNode.label = label;\n        }\n\n        return breakStatementNode;\n    }\n\n    /**\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} args\n     * @returns {CallExpression}\n     */\n    public static getCallExpressionNode (\n        callee: ESTree.Expression,\n        args: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.CallExpression {\n        return {\n            type: NodeType.CallExpression,\n            callee,\n            arguments: args,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {ContinueStatement}\n     */\n    public static getContinueStatement (label?: ESTree.Identifier): ESTree.ContinueStatement {\n        const continueStatementNode: ESTree.ContinueStatement = {\n            type: NodeType.ContinueStatement,\n            obfuscatedNode: false\n        };\n\n        if (label) {\n            continueStatementNode.label = label;\n        }\n\n        return continueStatementNode;\n    }\n\n    /**\n     * @param {Expression} expression\n     * @returns {ExpressionStatement}\n     */\n    public static getExpressionStatementNode (expression: ESTree.Expression): ESTree.ExpressionStatement {\n        return {\n            type: NodeType.ExpressionStatement,\n            expression,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {string} functionName\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionDeclaration}\n     */\n    public static getFunctionDeclarationNode (\n        functionName: string,\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionDeclaration {\n        return {\n            type: NodeType.FunctionDeclaration,\n            id: Nodes.getIdentifierNode(functionName),\n            params,\n            body,\n            generator: false,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionExpression}\n     */\n    public static getFunctionExpressionNode (\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionExpression {\n        return {\n            type: NodeType.FunctionExpression,\n            params,\n            body,\n            generator: false,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {BlockStatement} consequent\n     * @param {BlockStatement} alternate\n     * @returns {IfStatement}\n     */\n    public static getIfStatementNode (\n        test: ESTree.Expression,\n        consequent: ESTree.BlockStatement,\n        alternate?: ESTree.BlockStatement\n    ): ESTree.IfStatement {\n        return {\n            type: NodeType.IfStatement,\n            test,\n            consequent,\n            ...alternate && { alternate },\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {string} name\n     * @returns {Identifier}\n     */\n    public static getIdentifierNode (name: string): ESTree.Identifier {\n        return {\n            type: NodeType.Identifier,\n            name,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {boolean | number | string} value\n     * @param {string} raw\n     * @returns {Literal}\n     */\n    public static getLiteralNode (value: boolean | number | string, raw?: string): ESTree.Literal {\n        raw = raw !== undefined ? raw : `'${value}'`;\n\n        return {\n            type: NodeType.Literal,\n            value,\n            raw,\n            'x-verbatim-property': {\n                content: raw,\n                precedence: escodegen.Precedence.Primary\n            },\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {LogicalExpression}\n     */\n    public static getLogicalExpressionNode (\n        operator: ESTree.LogicalOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.LogicalExpression {\n        return {\n            type: NodeType.LogicalExpression,\n            operator,\n            left,\n            right,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {Expression | Super} object\n     * @param {Expression} property\n     * @param {boolean} computed\n     * @returns {MemberExpression}\n     */\n    public static getMemberExpressionNode (\n        object: ESTree.Expression | ESTree.Super,\n        property: ESTree.Expression,\n        computed: boolean = false\n    ): ESTree.MemberExpression {\n        return {\n            type: NodeType.MemberExpression,\n            computed,\n            object,\n            property,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {FunctionExpression} value\n     * @param {\"constructor\" | \"method\" | \"get\" | \"set\"} kind\n     * @param {boolean} computed\n     * @returns {MethodDefinition}\n     */\n    public static getMethodDefinitionNode (\n        key: ESTree.Expression,\n        value: ESTree.FunctionExpression,\n        kind: 'constructor' | 'method' | 'get' | 'set',\n        computed: boolean,\n    ): ESTree.MethodDefinition {\n        return {\n            type: NodeType.MethodDefinition,\n            key,\n            value,\n            kind,\n            computed,\n            static: false,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @returns {ObjectExpression}\n     */\n    public static getObjectExpressionNode (properties: ESTree.Property[]): ESTree.ObjectExpression {\n        return {\n            type: NodeType.ObjectExpression,\n            properties,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {Expression | Pattern} value\n     * @param {boolean} computed\n     * @returns {Property}\n     */\n    public static getPropertyNode (\n        key: ESTree.Expression,\n        value: ESTree.Expression | ESTree.Pattern,\n        computed: boolean = false\n    ): ESTree.Property {\n        return {\n            type: NodeType.Property,\n            key,\n            value,\n            kind: 'init',\n            method: false,\n            shorthand: false,\n            computed,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {UnaryOperator} operator\n     * @param {Expression} argument\n     * @param {true} prefix\n     * @returns {UnaryExpression}\n     */\n    public static getUnaryExpressionNode (\n        operator: ESTree.UnaryOperator,\n        argument: ESTree.Expression,\n        prefix: true = true\n    ): ESTree.UnaryExpression {\n        return {\n            type: NodeType.UnaryExpression,\n            operator,\n            argument,\n            prefix,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {Expression} argument\n     * @returns {ReturnStatement}\n     */\n    public static getReturnStatementNode (argument: ESTree.Expression): ESTree.ReturnStatement {\n        return {\n            type: NodeType.ReturnStatement,\n            argument,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {Expression} discriminant\n     * @param {SwitchCase[]} cases\n     * @returns {SwitchStatement}\n     */\n    public static getSwitchStatementNode (\n        discriminant: ESTree.Expression,\n        cases: ESTree.SwitchCase[]\n    ): ESTree.SwitchStatement {\n        return {\n            type: NodeType.SwitchStatement,\n            discriminant,\n            cases,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement[]} consequent\n     * @returns {SwitchCase}\n     */\n    public static getSwitchCaseNode (test: ESTree.Expression, consequent: ESTree.Statement[]): ESTree.SwitchCase {\n        return {\n            type: NodeType.SwitchCase,\n            test,\n            consequent,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {UpdateOperator} operator\n     * @param {Expression} argumentExpr\n     * @returns {UpdateExpression}\n     */\n    public static getUpdateExpressionNode (operator: ESTree.UpdateOperator, argumentExpr: ESTree.Expression): ESTree.UpdateExpression {\n        return {\n            type: NodeType.UpdateExpression,\n            operator,\n            argument: argumentExpr,\n            prefix: false,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {VariableDeclarator[]} declarations\n     * @param {string} kind\n     * @returns {VariableDeclaration}\n     */\n    public static getVariableDeclarationNode (\n        declarations: ESTree.VariableDeclarator[] = [],\n        kind: 'var' | 'let' | 'const' = 'var'\n    ): ESTree.VariableDeclaration {\n        return {\n            type: NodeType.VariableDeclaration,\n            declarations,\n            kind,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {Identifier} id\n     * @param {Expression | null} init\n     * @returns {VariableDeclarator}\n     */\n    public static getVariableDeclaratorNode (id: ESTree.Identifier, init: ESTree.Expression | null): ESTree.VariableDeclarator {\n        return {\n            type: NodeType.VariableDeclarator,\n            id,\n            init,\n            obfuscatedNode: false\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement} body\n     * @returns {WhileStatement}\n     */\n    public static getWhileStatementNode (test: ESTree.Expression, body: ESTree.Statement): ESTree.WhileStatement {\n        return {\n            type: NodeType.WhileStatement,\n            test,\n            body,\n            obfuscatedNode: false\n        };\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node/Nodes.ts","module.exports = require(\"estraverse\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"estraverse\"\n// module id = 10\n// module chunks = 0","export enum NodeType {\n    ArrayExpression = 'ArrayExpression',\n    ArrayPattern = 'ArrayPattern',\n    ArrowFunctionExpression = 'ArrowFunctionExpression',\n    AssignmentExpression = 'AssignmentExpression',\n    AssignmentPattern = 'AssignmentPattern',\n    AwaitExpression = 'AwaitExpression',\n    BinaryExpression = 'BinaryExpression',\n    BlockStatement = 'BlockStatement',\n    BreakStatement = 'BreakStatement',\n    CallExpression = 'CallExpression',\n    CatchClause = 'CatchClause',\n    ClassDeclaration = 'ClassDeclaration',\n    ContinueStatement = 'ContinueStatement',\n    ExpressionStatement = 'ExpressionStatement',\n    FunctionDeclaration = 'FunctionDeclaration',\n    FunctionExpression = 'FunctionExpression',\n    Identifier = 'Identifier',\n    IfStatement = 'IfStatement',\n    LabeledStatement = 'LabeledStatement',\n    Literal = 'Literal',\n    LogicalExpression = 'LogicalExpression',\n    MemberExpression = 'MemberExpression',\n    MethodDefinition = 'MethodDefinition',\n    ObjectExpression = 'ObjectExpression',\n    ObjectPattern = 'ObjectPattern',\n    Program = 'Program',\n    Property = 'Property',\n    RestElement = 'RestElement',\n    ReturnStatement = 'ReturnStatement',\n    Super = 'Super',\n    SwitchCase = 'SwitchCase',\n    SwitchStatement = 'SwitchStatement',\n    TemplateLiteral = 'TemplateLiteral',\n    TryStatement = 'TryStatement',\n    UnaryExpression = 'UnaryExpression',\n    UpdateExpression = 'UpdateExpression',\n    VariableDeclaration = 'VariableDeclaration',\n    VariableDeclarator = 'VariableDeclarator',\n    WhileStatement = 'WhileStatement'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/node/NodeType.ts","module.exports = require(\"string-template\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"string-template\"\n// module id = 12\n// module chunks = 0","export enum ControlFlowCustomNode {\n    BinaryExpressionFunctionNode = 'BinaryExpressionFunctionNode',\n    BlockStatementControlFlowFlatteningNode = 'BlockStatementControlFlowFlatteningNode',\n    CallExpressionControlFlowStorageCallNode = 'CallExpressionControlFlowStorageCallNode',\n    CallExpressionFunctionNode = 'CallExpressionFunctionNode',\n    ControlFlowStorageNode = 'ControlFlowStorageNode',\n    ExpressionWithOperatorControlFlowStorageCallNode = 'ExpressionWithOperatorControlFlowStorageCallNode',\n    LogicalExpressionFunctionNode = 'LogicalExpressionFunctionNode',\n    StringLiteralControlFlowStorageCallNode = 'StringLiteralControlFlowStorageCallNode',\n    StringLiteralNode = 'StringLiteralNode'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/custom-nodes/ControlFlowCustomNode.ts","export enum ObfuscationTarget {\n    Browser = 'browser',\n    Extension = 'extension',\n    Node = 'node'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/ObfuscationTarget.ts","import { Container, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from './ServiceIdentifiers';\n\nimport { analyzersModule } from './modules/analyzers/AnalyzersModule';\nimport { controlFlowTransformersModule } from './modules/node-transformers/ControlFlowTransformersModule';\nimport { convertingTransformersModule } from './modules/node-transformers/ConvertingTransformersModule';\nimport { customNodesModule } from './modules/custom-nodes/CustomNodesModule';\nimport { finalizingTransformersModule } from './modules/node-transformers/FinalizingTransformersModule';\nimport { generatorsModule } from './modules/generators/GeneratorsModule';\nimport { nodeTransformersModule } from './modules/node-transformers/NodeTransformersModule';\nimport { obfuscatingTransformersModule } from './modules/node-transformers/ObfuscatingTransformersModule';\nimport { optionsModule } from './modules/options/OptionsModule';\nimport { preparingTransformersModule } from './modules/node-transformers/PreparingTransformersModule';\nimport { storagesModule } from './modules/storages/StoragesModule';\nimport { utilsModule } from './modules/utils/UtilsModule';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from '../interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from '../interfaces/IJavaScriptObfsucator';\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IObfuscationResult } from '../interfaces/IObfuscationResult';\nimport { ISourceCode } from '../interfaces/ISourceCode';\nimport { ISourceMapCorrector } from '../interfaces/source-map/ISourceMapCorrector';\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\n\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscator';\nimport { Logger } from '../logger/Logger';\nimport { ObfuscationEventEmitter } from '../event-emitters/ObfuscationEventEmitter';\nimport { ObfuscationResult } from '../ObfuscationResult';\nimport { SourceCode } from '../SourceCode';\nimport { SourceMapCorrector } from '../source-map/SourceMapCorrector';\nimport { TransformersRunner } from '../node-transformers/TransformersRunner';\n\nexport class InversifyContainerFacade implements IInversifyContainerFacade {\n    /**\n     * @type {interfaces.Container}\n     */\n    private readonly container: interfaces.Container;\n\n    constructor () {\n        this.container = new Container();\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            return (bindingName: T) => {\n                return context.container.getNamed<U>(serviceIdentifier, bindingName);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getCacheFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map <T, U> = new Map();\n\n            return (bindingName: T) => {\n                if (cache.has(bindingName)) {\n                    return <U>cache.get(bindingName);\n                }\n\n                const object: U = context.container.getNamed<U>(serviceIdentifier, bindingName);\n\n                cache.set(bindingName, object);\n\n                return object;\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<U>>} serviceIdentifier\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]} dependencies\n     * @returns {U}\n     */\n    public static getConstructorFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<interfaces.Newable<U>>,\n        ...dependencies: interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map<T, interfaces.Newable<U>> = new Map();\n            const cachedDependencies: Object[] = [];\n\n            return (bindingName: T) => {\n                dependencies.forEach((\n                    dependency: interfaces.ServiceIdentifier<interfaces.Newable<Object>>,\n                    index: number\n                ) => {\n                    if (!cachedDependencies[index]) {\n                        cachedDependencies[index] = context.container.get(dependency);\n                    }\n                });\n\n                if (cache.has(bindingName)) {\n                    return new (<interfaces.Newable<U>>cache.get(bindingName))(...cachedDependencies);\n                }\n\n                const constructor: interfaces.Newable<U> = context.container\n                    .getNamed<interfaces.Newable<U>>(\n                        serviceIdentifier,\n                        bindingName\n                    );\n\n                cache.set(bindingName, constructor);\n\n                return new constructor(...cachedDependencies);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @returns {T}\n     */\n    public get <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>): T {\n        return this.container.get<T>(serviceIdentifier);\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @param {string | number | symbol} named\n     * @returns {T}\n     */\n    public getNamed <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T {\n        return this.container.getNamed<T>(serviceIdentifier, named);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {TInputOptions} options\n     */\n    public load (sourceCode: string, options: TInputOptions): void {\n        this.container\n            .bind<ISourceCode>(ServiceIdentifiers.ISourceCode)\n            .toDynamicValue(() => new SourceCode(sourceCode))\n            .inSingletonScope();\n\n        this.container\n            .bind<TInputOptions>(ServiceIdentifiers.TInputOptions)\n            .toDynamicValue(() => options)\n            .inSingletonScope();\n\n        this.container\n            .bind<ILogger>(ServiceIdentifiers.ILogger)\n            .to(Logger)\n            .inSingletonScope();\n\n        this.container\n            .bind<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator)\n            .to(JavaScriptObfuscator)\n            .inSingletonScope();\n\n        this.container\n            .bind<ITransformersRunner>(ServiceIdentifiers.ITransformersRunner)\n            .to(TransformersRunner)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscationResult>(ServiceIdentifiers.IObfuscationResult)\n            .to(ObfuscationResult)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscationResult>(ServiceIdentifiers.Factory__IObfuscationResult)\n            .toFactory<IObfuscationResult>((context: interfaces.Context) => {\n                return (obfuscatedCode: string, sourceMap: string) => {\n                    const obfuscationResult: IObfuscationResult = context.container\n                        .get<IObfuscationResult>(ServiceIdentifiers.IObfuscationResult);\n\n                    obfuscationResult.initialize(obfuscatedCode, sourceMap);\n\n                    return obfuscationResult;\n                };\n            });\n\n        this.container\n            .bind<ISourceMapCorrector>(ServiceIdentifiers.ISourceMapCorrector)\n            .to(SourceMapCorrector)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscationEventEmitter>(ServiceIdentifiers.IObfuscationEventEmitter)\n            .to(ObfuscationEventEmitter)\n            .inSingletonScope();\n\n        // modules\n        this.container.load(analyzersModule);\n        this.container.load(controlFlowTransformersModule);\n        this.container.load(convertingTransformersModule);\n        this.container.load(customNodesModule);\n        this.container.load(finalizingTransformersModule);\n        this.container.load(generatorsModule);\n        this.container.load(nodeTransformersModule);\n        this.container.load(obfuscatingTransformersModule);\n        this.container.load(optionsModule);\n        this.container.load(preparingTransformersModule);\n        this.container.load(storagesModule);\n        this.container.load(utilsModule);\n    }\n\n    public unload (): void {\n        this.container.unbindAll();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/container/InversifyContainerFacade.ts","import * as ESTree from 'estree';\n\nimport { TNodeWithBlockScope } from '../types/node/TNodeWithBlockScope';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { IStackTraceData } from '../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\nimport { TNodeWithScope } from '../types/node/TNodeWithScope';\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeAppender {\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @param {TStatement[]} scopeStatements\n     */\n    public static appendNode (scopeNode: TNodeWithScope, scopeStatements: TStatement[]): void {\n        scopeStatements = NodeAppender.parentizeScopeStatementsBeforeAppend(scopeNode, scopeStatements);\n\n        NodeAppender.setScopeNodeStatements(scopeNode, [\n            ...NodeAppender.getScopeNodeStatements(scopeNode),\n            ...scopeStatements\n        ]);\n    }\n\n    /**\n     * Appends node into a first deepest BlockStatement in order of function calls\n     *\n     * For example:\n     *\n     * function Foo () {\n     *     var baz = function () {\n     *\n     *     }\n     *\n     *     baz();\n     * }\n     *\n     * foo();\n     *\n     * Appends node into block statement of `baz` function expression\n     *\n     * @param {IStackTraceData[]} blockScopeStackTraceData\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {TStatement[]} nodeBodyStatements\n     * @param {number} index\n     */\n    public static appendNodeToOptimalBlockScope (\n        blockScopeStackTraceData: IStackTraceData[],\n        blockScopeNode: TNodeWithBlockScope,\n        nodeBodyStatements: TStatement[],\n        index: number = 0\n    ): void {\n        let targetBlockScope: TNodeWithBlockScope;\n\n        if (!blockScopeStackTraceData.length) {\n            targetBlockScope = blockScopeNode;\n        } else {\n            targetBlockScope = NodeAppender.getOptimalBlockScope(\n                blockScopeStackTraceData,\n                index\n            );\n        }\n\n        NodeAppender.prependNode(targetBlockScope, nodeBodyStatements);\n    }\n\n    /**\n     * Returns deepest block scope node at given deep.\n     *\n     * @param {IStackTraceData[]} blockScopeTraceData\n     * @param {number} index\n     * @param {number} deep\n     * @returns {BlockStatement}\n     */\n    public static getOptimalBlockScope (\n        blockScopeTraceData: IStackTraceData[],\n        index: number,\n        deep: number = Infinity\n    ): ESTree.BlockStatement {\n        const firstCall: IStackTraceData = blockScopeTraceData[index];\n\n        if (deep <= 0) {\n            throw new Error(`Invalid \\`deep\\` argument value. Value should be bigger then 0.`);\n        }\n\n        if (deep > 1 && firstCall.stackTrace.length) {\n            return NodeAppender.getOptimalBlockScope(firstCall.stackTrace, 0, --deep);\n        } else {\n            return firstCall.callee;\n        }\n    }\n\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @param {TStatement[]} scopeStatements\n     * @param {Node} targetStatement\n     */\n    public static insertNodeAfter (scopeNode: TNodeWithScope, scopeStatements: TStatement[], targetStatement: ESTree.Statement): void {\n        const indexInScopeStatement: number = NodeAppender\n            .getScopeNodeStatements(scopeNode)\n            .indexOf(targetStatement);\n\n        NodeAppender.insertNodeAtIndex(scopeNode, scopeStatements, indexInScopeStatement + 1);\n    }\n\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @param {TStatement[]} scopeStatements\n     * @param {number} index\n     */\n    public static insertNodeAtIndex (scopeNode: TNodeWithScope, scopeStatements: TStatement[], index: number): void {\n        scopeStatements = NodeAppender.parentizeScopeStatementsBeforeAppend(scopeNode, scopeStatements);\n\n        NodeAppender.setScopeNodeStatements(scopeNode, [\n            ...NodeAppender.getScopeNodeStatements(scopeNode).slice(0, index),\n            ...scopeStatements,\n            ...NodeAppender.getScopeNodeStatements(scopeNode).slice(index)\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @param {TStatement[]} scopeStatements\n     */\n    public static prependNode (scopeNode: TNodeWithScope, scopeStatements: TStatement[]): void {\n        scopeStatements = NodeAppender.parentizeScopeStatementsBeforeAppend(scopeNode, scopeStatements);\n\n        NodeAppender.setScopeNodeStatements(scopeNode, [\n            ...scopeStatements,\n            ...NodeAppender.getScopeNodeStatements(scopeNode),\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @returns {TStatement[]}\n     */\n    private static getScopeNodeStatements (scopeNode: TNodeWithScope): TStatement[] {\n        if (NodeGuards.isSwitchCaseNode(scopeNode)) {\n            return scopeNode.consequent;\n        }\n\n        return scopeNode.body;\n    }\n\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @param {TStatement[]} scopeStatements\n     * @returns {TStatement[]}\n     */\n    private static parentizeScopeStatementsBeforeAppend (scopeNode: TNodeWithScope, scopeStatements: TStatement[]): TStatement[] {\n        scopeStatements.forEach((statement: TStatement) => {\n            statement.parentNode = scopeNode;\n        });\n\n        return scopeStatements;\n    }\n\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @param {TStatement[]} statements\n     */\n    private static setScopeNodeStatements (scopeNode: TNodeWithScope, statements: TStatement[]): void {\n        if (NodeGuards.isSwitchCaseNode(scopeNode)) {\n            scopeNode.consequent = <ESTree.Statement[]>statements;\n\n            return;\n        }\n\n        scopeNode.body = statements;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node/NodeAppender.ts","export enum ObfuscationEvent {\n    AfterObfuscation = 'afterObfuscation',\n    BeforeObfuscation = 'beforeObfuscation'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/event-emitters/ObfuscationEvent.ts","export enum IdentifierObfuscatingReplacer {\n    BaseIdentifierObfuscatingReplacer = 'BaseIdentifierObfuscatingReplacer'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer.ts","import 'reflect-metadata';\n\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport { TInputOptions } from './types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from './interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { IObfuscationResult } from './interfaces/IObfuscationResult';\n\nimport { InversifyContainerFacade } from './container/InversifyContainerFacade';\nimport { JavaScriptObfuscatorCLI } from './cli/JavaScriptObfuscatorCLI';\n\nclass JavaScriptObfuscatorFacade {\n    /**\n     * @param {string} sourceCode\n     * @param {TInputOptions} inputOptions\n     * @returns {IObfuscationResult}\n     */\n    public static obfuscate (sourceCode: string, inputOptions: TInputOptions = {}): IObfuscationResult {\n        const inversifyContainerFacade: IInversifyContainerFacade = new InversifyContainerFacade();\n\n        inversifyContainerFacade.load(sourceCode, inputOptions);\n\n        const javaScriptObfuscator: IJavaScriptObfuscator = inversifyContainerFacade\n            .get<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator);\n        const obfuscationResult: IObfuscationResult = javaScriptObfuscator.obfuscate(sourceCode);\n\n        inversifyContainerFacade.unload();\n\n        return obfuscationResult;\n    }\n\n    /**\n     * @param {string[]} argv\n     */\n    public static runCLI (argv: string[]): void {\n        const javaScriptObfuscatorCLI: JavaScriptObfuscatorCLI = new JavaScriptObfuscatorCLI(argv);\n\n        javaScriptObfuscatorCLI.initialize();\n        javaScriptObfuscatorCLI.run();\n    }\n}\n\nexport { JavaScriptObfuscatorFacade as JavaScriptObfuscator };\n\n\n\n// WEBPACK FOOTER //\n// ./src/JavaScriptObfuscatorFacade.ts","export enum NodeTransformer {\n    BlockStatementControlFlowTransformer = 'BlockStatementControlFlowTransformer',\n    ClassDeclarationTransformer = 'ClassDeclarationTransformer',\n    CommentsTransformer = 'CommentsTransformer',\n    CustomNodesTransformer = 'CustomNodesTransformer',\n    DeadCodeInjectionTransformer = 'DeadCodeInjectionTransformer',\n    EvalCallExpressionTransformer = 'EvalCallExpressionTransformer',\n    FunctionControlFlowTransformer = 'FunctionControlFlowTransformer',\n    CatchClauseTransformer = 'CatchClauseTransformer',\n    FunctionDeclarationTransformer = 'FunctionDeclarationTransformer',\n    FunctionTransformer = 'FunctionTransformer',\n    LabeledStatementTransformer = 'LabeledStatementTransformer',\n    LiteralTransformer = 'LiteralTransformer',\n    MemberExpressionTransformer = 'MemberExpressionTransformer',\n    MethodDefinitionTransformer = 'MethodDefinitionTransformer',\n    ObfuscatingGuardsTransformer = 'ObfuscatingGuardsTransformer',\n    ObjectExpressionKeysTransformer = 'ObjectExpressionKeysTransformer',\n    ObjectExpressionTransformer = 'ObjectExpressionTransformer',\n    ParentificationTransformer = 'ParentificationTransformer',\n    TemplateLiteralTransformer = 'TemplateLiteralTransformer',\n    VariableDeclarationTransformer = 'VariableDeclarationTransformer'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/node-transformers/NodeTransformer.ts","export enum CustomNode {\n    ConsoleOutputDisableExpressionNode = 'ConsoleOutputDisableExpressionNode',\n    DebugProtectionFunctionCallNode = 'DebugProtectionFunctionCallNode',\n    DebugProtectionFunctionIntervalNode = 'DebugProtectionFunctionIntervalNode',\n    DebugProtectionFunctionNode = 'DebugProtectionFunctionNode',\n    DomainLockNode = 'DomainLockNode',\n    NodeCallsControllerFunctionNode = 'NodeCallsControllerFunctionNode',\n    SelfDefendingUnicodeNode = 'SelfDefendingUnicodeNode',\n    StringArrayCallsWrapper = 'StringArrayCallsWrapper',\n    StringArrayNode = 'StringArrayNode',\n    StringArrayRotateFunctionNode = 'StringArrayRotateFunctionNode'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/custom-nodes/CustomNode.ts","import { JSFuck } from '../enums/JSFuck';\n\nexport class Utils {\n    /**\n     * @type {string}\n     */\n    public static readonly hexadecimalPrefix: string = '0x';\n\n    /**\n     * @param {number} dec\n     * @returns {string}\n     */\n    public static decToHex (dec: number): string {\n        const radix: number = 16;\n\n        return dec.toString(radix);\n    }\n\n    /**\n     * @param {string} url\n     * @returns {string}\n     */\n    public static extractDomainFromUrl (url: string): string {\n        let domain: string;\n\n        if (url.indexOf('://') > -1 || url.indexOf('//') === 0) {\n            domain = url.split('/')[2];\n        } else {\n            domain = url.split('/')[0];\n        }\n\n        domain = domain.split(':')[0];\n\n        return domain;\n    }\n\n    /**\n     * @param {number} number\n     * @returns {boolean}\n     */\n    public static isCeilNumber (number: number): boolean {\n        return number % 1 === 0;\n    }\n\n    /**\n     * @param {string} string\n     * @param {number} times\n     * @returns {string}\n     */\n    public static stringRotate (string: string, times: number): string {\n        if (!string) {\n            throw new ReferenceError(`Cannot rotate empty string.`);\n        }\n\n        for (let i: number = 0; i < times; i++) {\n            string = string[string.length - 1] + string.substring(0, string.length - 1);\n        }\n\n        return string;\n    }\n\n    /**\n     * @param {string} string\n     * @returns {string}\n     */\n    public static stringToJSFuck (string: string): string {\n        return Array\n            .from(string)\n            .map((character: string): string => {\n                return JSFuck[<any>character] || character;\n            })\n            .join(' + ');\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/Utils.ts","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { CustomNode } from '../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../enums/event-emitters/ObfuscationEvent';\n\n@injectable()\nexport abstract class AbstractCustomNodeGroup implements ICustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected abstract readonly appendEvent: ObfuscationEvent;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    protected abstract customNodes: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public abstract appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void;\n\n    /**\n     * @returns {ObfuscationEvent}\n     */\n    public getAppendEvent (): ObfuscationEvent {\n        return this.appendEvent;\n    }\n\n    /**\n     * @returns {Map<CustomNode, ICustomNode>}\n     */\n    public getCustomNodes (): Map <CustomNode, ICustomNode> {\n        return this.customNodes;\n    }\n\n    public abstract initialize (): void;\n\n    /**\n     * @param {CustomNode} customNodeName\n     * @param {callback} callback\n     */\n    protected appendCustomNodeIfExist (customNodeName: CustomNode, callback: (customNode: ICustomNode) => void): void {\n        const customNode: ICustomNode | undefined = this.customNodes.get(customNodeName);\n\n        if (!customNode) {\n            return;\n        }\n\n        callback(customNode);\n    }\n\n    /**\n     * @param {number} stackTraceLength\n     * @returns {number}\n     */\n    protected getRandomStackTraceIndex (stackTraceLength: number): number {\n        return this.randomGenerator.getRandomInteger(0, Math.max(0, Math.round(stackTraceLength - 1)));\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/AbstractCustomNodeGroup.ts","export enum IdentifierNamesGenerator {\n    HexadecimalIdentifierNamesGenerator = 'hexadecimal',\n    MangledIdentifierNamesGenerator = 'mangled'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/generators/identifier-names-generators/IdentifierNamesGenerator.ts","export enum SourceMapMode {\n    Inline = 'inline',\n    Separate = 'separate'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/source-map/SourceMapMode.ts","export enum StringArrayEncoding {\n    Base64 = 'base64',\n    Rc4 = 'rc4'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/StringArrayEncoding.ts","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const NO_ADDITIONAL_NODES_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    rotateStringArray: false,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: false,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/presets/NoCustomNodes.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\n@injectable()\nexport abstract class AbstractObfuscatingReplacer implements IObfuscatingReplacer {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {SimpleLiteral['value']} nodeValue\n     * @param {number} nodeIdentifier\n     * @returns {Node}\n     */\n    public abstract replace (nodeValue: ESTree.SimpleLiteral['value'], nodeIdentifier?: number): ESTree.Node;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/obfuscating-transformers/obfuscating-replacers/AbstractObfuscatingReplacer.ts","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeDataExtractor';\n\n@injectable()\nexport abstract class AbstractCalleeDataExtractor implements ICalleeDataExtractor {\n    /**\n     * @param {Node[]} blockScopeBody\n     * @param {Node} callee\n     * @returns {ICalleeData}\n     */\n    public abstract extract (blockScopeBody: ESTree.Node[], callee: ESTree.Node): ICalleeData | null;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/analyzers/stack-trace-analyzer/callee-data-extractors/AbstractCalleeDataExtractor.ts","module.exports = require(\"escodegen-wallaby\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"escodegen-wallaby\"\n// module id = 30\n// module chunks = 0","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStorage } from '../../../interfaces/storages/IStorage';\n\n@injectable()\nexport abstract class AbstractControlFlowReplacer implements IControlFlowReplacer {\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    protected readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {Map<string, Map<string, string[]>>}\n     */\n    protected readonly replacerDataByControlFlowStorageId: Map <string, Map<string, string[]>> = new Map();\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Map<string, Map<string, string[]>>} identifierDataByControlFlowStorageId\n     * @param {string} controlFlowStorageId\n     * @returns {Map<string, string[]>}\n     */\n    protected static getStorageKeysByIdForCurrentStorage (\n        identifierDataByControlFlowStorageId: Map<string, Map<string, string[]>>,\n        controlFlowStorageId: string\n    ): Map<string, string[]> {\n        let storageKeysById: Map<string, string[]>;\n\n        if (identifierDataByControlFlowStorageId.has(controlFlowStorageId)) {\n            storageKeysById = <Map<string, string[]>>identifierDataByControlFlowStorageId.get(controlFlowStorageId);\n        } else {\n            storageKeysById = new Map <string, string[]>();\n        }\n\n        return storageKeysById;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @param {IStorage<ICustomNode>} controlFlowStorage\n     * @returns {Node}\n     */\n    public abstract replace (node: ESTree.Node, parentNode: ESTree.Node, controlFlowStorage: IStorage <ICustomNode>): ESTree.Node;\n\n    /**\n     * @param {ICustomNode} customNode\n     * @param {IStorage<ICustomNode>} controlFlowStorage\n     * @param {string} replacerId\n     * @param {number} usingExistingIdentifierChance\n     * @returns {string}\n     */\n    protected insertCustomNodeToControlFlowStorage (\n        customNode: ICustomNode,\n        controlFlowStorage: IStorage <ICustomNode>,\n        replacerId: string,\n        usingExistingIdentifierChance: number\n    ): string {\n        const controlFlowStorageId: string = controlFlowStorage.getStorageId();\n        const storageKeysById: Map<string, string[]> = AbstractControlFlowReplacer\n            .getStorageKeysByIdForCurrentStorage(this.replacerDataByControlFlowStorageId, controlFlowStorageId);\n        const storageKeysForCurrentId: string[] | undefined = storageKeysById.get(replacerId);\n\n        if (\n            this.randomGenerator.getMathRandom() < usingExistingIdentifierChance &&\n            storageKeysForCurrentId &&\n            storageKeysForCurrentId.length\n        ) {\n            return this.randomGenerator.getRandomGenerator().pickone(storageKeysForCurrentId);\n        }\n\n        const generateStorageKey: (length: number) => string = (length: number) => {\n            const key: string = this.randomGenerator.getRandomString(length);\n\n            if (controlFlowStorage.getStorage().has(key)) {\n                return generateStorageKey(length);\n            }\n\n            return key;\n        };\n        const storageKey: string = generateStorageKey(5);\n\n        storageKeysById.set(replacerId, [storageKey]);\n        this.replacerDataByControlFlowStorageId.set(controlFlowStorageId, storageKeysById);\n        controlFlowStorage.set(storageKey, customNode);\n\n        return storageKey;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/control-flow-transformers/control-flow-replacers/AbstractControlFlowReplacer.ts","/**\n * @returns {string}\n */\nexport function GlobalVariableNoEvalTemplate (): string {\n    return `\n        var that = (typeof window !== 'undefined'\n           ? window\n           : (typeof process === 'object' &&\n              typeof require === 'function' &&\n              typeof global === 'object')\n             ? global\n             : this);\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/GlobalVariableNoEvalTemplate.ts","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const DEFAULT_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    config: '',\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0.75,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0.4,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    rotateStringArray: true,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: true,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0.75,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/presets/Default.ts","import * as commander from 'commander';\nimport * as packageJson from 'pjson';\nimport * as path from 'path';\n\nimport { TInputCLIOptions } from '../types/options/TInputCLIOptions';\nimport { TInputOptions } from '../types/options/TInputOptions';\nimport { TSourceCodeData } from '../types/cli/TSourceCodeData';\n\nimport { IFileData } from '../interfaces/cli/IFileData';\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { IObfuscationResult } from '../interfaces/IObfuscationResult';\n\nimport { initializable } from '../decorators/Initializable';\n\nimport { DEFAULT_PRESET } from '../options/presets/Default';\n\nimport { ArraySanitizer } from './sanitizers/ArraySanitizer';\nimport { BooleanSanitizer } from './sanitizers/BooleanSanitizer';\nimport { IdentifierNamesGeneratorSanitizer } from './sanitizers/IdentifierNamesGeneratorSanitizer';\nimport { ObfuscationTargetSanitizer } from './sanitizers/ObfuscatingTargetSanitizer';\nimport { SourceMapModeSanitizer } from './sanitizers/SourceMapModeSanitizer';\nimport { StringArrayEncodingSanitizer } from './sanitizers/StringArrayEncodingSanitizer';\n\nimport { CLIUtils } from './utils/CLIUtils';\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscatorFacade';\nimport { SourceCodeReader } from './utils/SourceCodeReader';\n\nexport class JavaScriptObfuscatorCLI implements IInitializable {\n    /**\n     * @type {string[]}\n     */\n    public static readonly availableInputExtensions: string[] = [\n        '.js'\n    ];\n\n    /**\n     * @type {BufferEncoding}\n     */\n    public static readonly encoding: BufferEncoding = 'utf8';\n\n    /**\n     * @type {string}\n     */\n    public static obfuscatedFilePrefix: string = '-obfuscated';\n\n    /**\n     * @type {string}\n     */\n    private static readonly baseIdentifiersPrefix: string = 'a';\n\n    /**\n     * @type {string[]}\n     */\n    private readonly arguments: string[];\n\n    /**\n     * @type {string[]}\n     */\n    private readonly rawArguments: string[];\n\n    /**\n     * @type {commander.CommanderStatic}\n     */\n    @initializable()\n    private commands!: commander.CommanderStatic;\n\n    /**\n     * @type {TInputCLIOptions}\n     */\n    @initializable()\n    private inputCLIOptions!: TInputCLIOptions;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private inputPath!: string;\n\n    /**\n     * @param {string[]} argv\n     */\n    constructor (argv: string[]) {\n        this.rawArguments = argv;\n        this.arguments = argv.slice(2);\n    }\n\n    /**\n     * @param {TObject} options\n     * @returns {TInputOptions}\n     */\n    private static filterOptions (options: TInputCLIOptions): TInputOptions {\n        const filteredOptions: TInputOptions = {};\n\n        for (const option in options) {\n            if (!options.hasOwnProperty(option) || options[option] === undefined) {\n                continue;\n            }\n\n            filteredOptions[option] = options[option];\n        }\n\n        return filteredOptions;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {TInputOptions} options\n     */\n    private static processSourceCodeWithoutSourceMap (\n        sourceCode: string,\n        outputCodePath: string,\n        options: TInputOptions\n    ): void {\n        const obfuscatedCode: string = JavaScriptObfuscator.obfuscate(sourceCode, options).getObfuscatedCode();\n\n        CLIUtils.writeFile(outputCodePath, obfuscatedCode);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {TInputOptions} options\n     */\n    private static processSourceCodeWithSourceMap (\n        sourceCode: string,\n        outputCodePath: string,\n        options: TInputOptions\n    ): void {\n        const outputSourceMapPath: string = CLIUtils.getOutputSourceMapPath(\n            outputCodePath,\n            options.sourceMapFileName || ''\n        );\n\n        options = {\n            ...options,\n            sourceMapFileName: path.basename(outputSourceMapPath)\n        };\n\n        const obfuscationResult: IObfuscationResult = JavaScriptObfuscator.obfuscate(sourceCode, options);\n\n        CLIUtils.writeFile(outputCodePath, obfuscationResult.getObfuscatedCode());\n\n        if (options.sourceMapMode === 'separate' && obfuscationResult.getSourceMap()) {\n            CLIUtils.writeFile(outputSourceMapPath, obfuscationResult.getSourceMap());\n        }\n    }\n\n    public initialize (): void {\n        this.inputPath = path.normalize(this.arguments[0] || '');\n        this.commands = <commander.CommanderStatic>(new commander.Command());\n\n        this.configureCommands();\n        this.configureHelp();\n\n        this.inputCLIOptions = this.commands.opts();\n    }\n\n    public run (): void {\n        const canShowHelp: boolean = !this.arguments.length || this.arguments.includes('--help');\n\n        if (canShowHelp) {\n            return this.commands.outputHelp();\n        }\n\n        const sourceCodeData: TSourceCodeData = SourceCodeReader.readSourceCode(this.inputPath);\n\n        this.processSourceCodeData(sourceCodeData);\n    }\n\n    /**\n     * @returns {TInputOptions}\n     */\n    private buildOptions (): TInputOptions {\n        const inputCLIOptions: TInputOptions = JavaScriptObfuscatorCLI.filterOptions(this.inputCLIOptions);\n        const configFilePath: string | undefined = this.inputCLIOptions.config;\n        const configFileLocation: string = configFilePath ? path.resolve(configFilePath, '.') : '';\n        const configFileOptions: TInputOptions = configFileLocation ? CLIUtils.getUserConfig(configFileLocation) : {};\n\n        return {\n            ...DEFAULT_PRESET,\n            ...configFileOptions,\n            ...inputCLIOptions\n        };\n    }\n\n    private configureCommands (): void {\n        this.commands\n            .usage('<inputPath> [options]')\n            .version(\n                packageJson.version,\n                '-v, --version'\n            )\n            .option(\n                '-o, --output <path>',\n                'Output path for obfuscated code'\n            )\n            .option(\n                '--compact <boolean>',\n                'Disable one line output code compacting',\n                BooleanSanitizer\n            )\n            .option(\n                '--config <boolean>',\n                'Name of js / json config file'\n            )\n            .option(\n                '--control-flow-flattening <boolean>',\n                'Enables control flow flattening',\n                BooleanSanitizer\n            )\n            .option(\n                '--control-flow-flattening-threshold <number>',\n                'The probability that the control flow flattening transformation will be applied to the node',\n                parseFloat\n            )\n            .option(\n                '--dead-code-injection <boolean>',\n                'Enables dead code injection',\n                BooleanSanitizer\n            )\n            .option(\n                '--dead-code-injection-threshold <number>',\n                'The probability that the dead code injection transformation will be applied to the node',\n                parseFloat\n            )\n            .option(\n                '--debug-protection <boolean>',\n                'Disable browser Debug panel (can cause DevTools enabled browser freeze)',\n                BooleanSanitizer\n            )\n            .option(\n                '--debug-protection-interval <boolean>',\n                'Disable browser Debug panel even after page was loaded (can cause DevTools enabled browser freeze)',\n                BooleanSanitizer\n            )\n            .option(\n                '--disable-console-output <boolean>',\n                'Allow console.log, console.info, console.error and console.warn messages output into browser console',\n                BooleanSanitizer\n            )\n            .option(\n                '--domain-lock <list> (comma separated, without whitespaces)',\n                'Blocks the execution of the code in domains that do not match the passed RegExp patterns (comma separated)',\n                ArraySanitizer\n            )\n            .option(\n                '--identifier-names-generator <string> [hexadecimal, mangled]', 'Sets identifier names generator (Default: hexadecimal)',\n                IdentifierNamesGeneratorSanitizer\n            )\n            .option(\n                '--identifiers-prefix <string>',\n                'Sets prefix for all global identifiers.'\n            )\n            .option(\n                '--log <boolean>', 'Enables logging of the information to the console',\n                BooleanSanitizer\n            )\n            .option(\n                '--reserved-names <list> (comma separated, without whitespaces)',\n                'Disable obfuscation of variable names, function names and names of function parameters that match the passed RegExp patterns (comma separated)',\n                ArraySanitizer\n            )\n            .option(\n                '--rename-globals <boolean>', 'Allows to enable obfuscation of global variable and function names with declaration.',\n                BooleanSanitizer\n            )\n            .option(\n                '--rotate-string-array <boolean>', 'Disable rotation of unicode array values during obfuscation',\n                BooleanSanitizer\n            )\n            .option(\n                '--seed <number>',\n                'Sets seed for random generator. This is useful for creating repeatable results.',\n                parseFloat\n            )\n            .option(\n                '--self-defending <boolean>',\n                'Disables self-defending for obfuscated code',\n                BooleanSanitizer\n            )\n            .option(\n                '--source-map <boolean>',\n                'Enables source map generation',\n                BooleanSanitizer\n            )\n            .option(\n                '--source-map-base-url <string>',\n                'Sets base url to the source map import url when `--source-map-mode=separate`'\n            )\n            .option(\n                '--source-map-file-name <string>',\n                'Sets file name for output source map when `--source-map-mode=separate`'\n            )\n            .option(\n                '--source-map-mode <string> [inline, separate]',\n                'Specify source map output mode',\n                SourceMapModeSanitizer\n            )\n            .option(\n                '--string-array <boolean>',\n                'Disables gathering of all literal strings into an array and replacing every literal string with an array call',\n                BooleanSanitizer\n            )\n            .option(\n                '--string-array-encoding <string|boolean> [true, false, base64, rc4]',\n                'Encodes all strings in strings array using base64 or rc4 (this option can slow down your code speed',\n                StringArrayEncodingSanitizer\n            )\n            .option(\n                '--string-array-threshold <number>',\n                'The probability that the literal string will be inserted into stringArray (Default: 0.8, Min: 0, Max: 1)',\n                parseFloat\n            )\n            .option(\n                '--target <string>',\n                'Allows to set target environment for obfuscated code.',\n                ObfuscationTargetSanitizer\n            )\n            .option(\n                '--transform-object-keys <boolean>',\n                'Enables transformation of object keys',\n                BooleanSanitizer\n            )\n            .option(\n                '--unicode-escape-sequence <boolean>',\n                'Allows to enable/disable string conversion to unicode escape sequence',\n                BooleanSanitizer\n            )\n            .parse(this.rawArguments);\n    }\n\n    private configureHelp (): void {\n        this.commands.on('--help', () => {\n            console.log('  Examples:\\n');\n            console.log('    %> javascript-obfuscator input_file_name.js --compact true --self-defending false');\n            console.log('    %> javascript-obfuscator input_file_name.js --output output_file_name.js --compact true --self-defending false');\n            console.log('    %> javascript-obfuscator input_directory_name --compact true --self-defending false');\n            console.log('');\n        });\n    }\n\n    /**\n     * @param {TSourceCodeData} sourceCodeData\n     */\n    private processSourceCodeData (sourceCodeData: TSourceCodeData): void {\n        const outputPath: string = this.inputCLIOptions.output\n            ? path.normalize(this.inputCLIOptions.output)\n            : '';\n\n        if (!Array.isArray(sourceCodeData)) {\n            const outputCodePath: string = outputPath || CLIUtils.getOutputCodePath(this.inputPath);\n\n            this.processSourceCode(sourceCodeData, outputCodePath, null);\n        } else {\n            sourceCodeData.forEach(({ filePath, content }: IFileData, index: number) => {\n                const outputCodePath: string = outputPath\n                    ? path.join(outputPath, filePath)\n                    : CLIUtils.getOutputCodePath(filePath);\n\n                this.processSourceCode(content, outputCodePath, index);\n            });\n        }\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {number | null} sourceCodeIndex\n     */\n    private processSourceCode (\n        sourceCode: string,\n        outputCodePath: string,\n        sourceCodeIndex: number | null\n    ): void {\n        let options: TInputOptions = this.buildOptions();\n\n        if (sourceCodeIndex !== null) {\n            const baseIdentifiersPrefix: string = this.inputCLIOptions.identifiersPrefix\n                || JavaScriptObfuscatorCLI.baseIdentifiersPrefix;\n            const identifiersPrefix: string = `${baseIdentifiersPrefix}${sourceCodeIndex}`;\n\n            options = {\n                ...options,\n                identifiersPrefix\n            };\n        }\n\n        if (options.sourceMap) {\n            JavaScriptObfuscatorCLI.processSourceCodeWithSourceMap(sourceCode, outputCodePath, options);\n        } else {\n            JavaScriptObfuscatorCLI.processSourceCodeWithoutSourceMap(sourceCode, outputCodePath, options);\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/cli/JavaScriptObfuscatorCLI.ts","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 35\n// module chunks = 0","export enum CalleeDataExtractor {\n    FunctionDeclarationCalleeDataExtractor = 'FunctionDeclarationCalleeDataExtractor',\n    FunctionExpressionCalleeDataExtractor = 'FunctionExpressionCalleeDataExtractor',\n    ObjectExpressionCalleeDataExtractor = 'ObjectExpressionCalleeDataExtractor',\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/analyzers/stack-trace-analyzer/CalleeDataExtractor.ts","module.exports = require(\"esprima\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"esprima\"\n// module id = 37\n// module chunks = 0","export enum ControlFlowReplacer {\n    BinaryExpressionControlFlowReplacer = 'BinaryExpressionControlFlowReplacer',\n    CallExpressionControlFlowReplacer = 'CallExpressionControlFlowReplacer',\n    LogicalExpressionControlFlowReplacer = 'LogicalExpressionControlFlowReplacer',\n    StringLiteralControlFlowReplacer = 'StringLiteralControlFlowReplacer'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport abstract class ExpressionWithOperatorControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        leftExpression: ESTree.Expression,\n        rightExpression: ESTree.Expression\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, leftExpression, rightExpression);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/control-flow-transformers/control-flow-replacers/ExpressionWithOperatorControlFlowReplacer.ts","export enum DeadCodeInjectionCustomNode {\n    BlockStatementDeadCodeInjectionNode = 'BlockStatementDeadCodeInjectionNode'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/custom-nodes/DeadCodeInjectionCustomNode.ts","export enum CustomNodeGroup {\n    ConsoleOutputCustomNodeGroup = 'ConsoleOutputCustomNodeGroup',\n    DebugProtectionCustomNodeGroup = 'DebugProtectionCustomNodeGroup',\n    DomainLockCustomNodeGroup = 'DomainLockCustomNodeGroup',\n    SelfDefendingCustomNodeGroup = 'SelfDefendingCustomNodeGroup',\n    StringArrayCustomNodeGroup = 'StringArrayCustomNodeGroup'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/custom-nodes/CustomNodeGroup.ts","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractIdentifierNamesGenerator implements IIdentifierNamesGenerator {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public abstract generate (): string;\n\n    /**\n     * @returns {string}\n     */\n    public abstract generateWithPrefix (): string;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/generators/identifier-names-generators/AbstractIdentifierNamesGenerator.ts","export enum LiteralObfuscatingReplacer {\n    BooleanLiteralObfuscatingReplacer = 'BooleanLiteralObfuscatingReplacer',\n    NumberLiteralObfuscatingReplacer = 'NumberLiteralObfuscatingReplacer',\n    StringLiteralObfuscatingReplacer = 'StringLiteralObfuscatingReplacer'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer.ts","export enum ObfuscatingGuard {\n    BlackListNodeGuard = 'BlackListNodeGuard',\n    ConditionalCommentNodeGuard = 'ConditionalCommentNodeGuard'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard.ts","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IStorage } from '../interfaces/storages/IStorage';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class MapStorage <T> implements IStorage <T> {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {Map <string | number, T>}\n     */\n    @initializable()\n    protected storage!: Map <string | number, T>;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = new Map <string | number, T>();\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {string | number} key\n     * @returns {T}\n     */\n    public get (key: string | number): T {\n        const value: T | undefined = this.storage.get(key);\n\n        if (!value) {\n            throw new Error(`No value found in map storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {T} value\n     * @returns {string | number | null}\n     */\n    public getKeyOf (value: T): string | number | null {\n        for (const [key, storageValue] of this.storage) {\n            if (value === storageValue) {\n                return key;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storage.size;\n    }\n\n    /**\n     * @returns {Map <string | number, T>}\n     */\n    public getStorage (): Map <string | number, T> {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = new Map <string | number, T>([...this.storage, ...storage.getStorage()]);\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {string | number} key\n     * @param {T} value\n     */\n    public set (key: string | number, value: T): void {\n        this.storage.set(key, value);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/storages/MapStorage.ts","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport md5 from 'md5';\nimport { Chance } from 'chance';\n\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { ISourceCode } from '../interfaces/ISourceCode';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport class RandomGenerator implements IRandomGenerator, IInitializable {\n    /**\n     * @type {string}\n     */\n    public static readonly randomGeneratorPool: string = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {Chance.Chance | Chance.SeededChance}\n     */\n    @initializable()\n    private randomGenerator!: Chance.Chance | Chance.SeededChance;\n\n    /**\n     * @type {number}\n     */\n    @initializable()\n    private seed!: number;\n\n    /**\n     * @type {ISourceCode}\n     */\n    private readonly sourceCode: ISourceCode;\n\n    /**\n     * @param {ISourceCode} sourceCode\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ISourceCode) sourceCode: ISourceCode,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.sourceCode = sourceCode;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        const getRandomInteger: (min: number, max: number) => number = (min: number, max: number) => {\n            return Math.floor(Math.random() * (max - min + 1) + min);\n        };\n\n        /**\n         * We need to add numbers from md5 hash of source code to input seed to prevent same String Array name\n         * for different bundles with same seed\n         *\n         * @returns {number}\n         */\n        const getSeed: () => number = (): number => {\n            const md5Hash: string = md5(this.sourceCode.getSourceCode());\n\n            return this.seed + Number(md5Hash.replace(/\\D/g, ''));\n        };\n\n        this.seed = this.options.seed !== 0 ? this.options.seed : getRandomInteger(0, 999_999_999);\n        this.randomGenerator = new Chance(getSeed());\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getMathRandom (): number {\n        return this.getRandomInteger(0, 99999) / 100000;\n    }\n\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @returns {number}\n     */\n    public getRandomFloat (min: number, max: number): number {\n        return this.getRandomGenerator().floating({\n            min: min,\n            max: max,\n            fixed: 7\n        });\n    }\n\n    /**\n     * @returns {Chance.Chance}\n     */\n    public getRandomGenerator (): Chance.Chance {\n        return this.randomGenerator;\n    }\n\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @returns {number}\n     */\n    public getRandomInteger (min: number, max: number): number {\n        return this.getRandomGenerator().integer({\n            min: min,\n            max: max\n        });\n    }\n\n    /**\n     * @param {number} length\n     * @param {string} pool\n     * @returns {string}\n     */\n    public getRandomString (length: number, pool: string = RandomGenerator.randomGeneratorPool): string {\n        return this.getRandomGenerator().string({ length, pool });\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getSeed (): number {\n        return this.seed;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/RandomGenerator.ts","module.exports = require(\"pjson\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"pjson\"\n// module id = 47\n// module chunks = 0","module.exports = require(\"chalk\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"chalk\"\n// module id = 48\n// module chunks = 0","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 49\n// module chunks = 0","\"use strict\";\n\nimport { JavaScriptObfuscator } from './src/JavaScriptObfuscatorFacade';\n\nmodule.exports = JavaScriptObfuscator;\n\n\n\n// WEBPACK FOOTER //\n// ./index.ts","module.exports = require(\"reflect-metadata\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"reflect-metadata\"\n// module id = 51\n// module chunks = 0","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeDataExtractor';\nimport { IStackTraceAnalyzer } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\n\nimport { CalleeDataExtractor } from '../../../enums/analyzers/stack-trace-analyzer/CalleeDataExtractor';\nimport { FunctionDeclarationCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor';\nimport { FunctionExpressionCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor';\nimport { ObjectExpressionCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor';\nimport { StackTraceAnalyzer } from '../../../analyzers/stack-trace-analyzer/StackTraceAnalyzer';\n\nexport const analyzersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // stack trace analyzer\n    bind<IStackTraceAnalyzer>(ServiceIdentifiers.IStackTraceAnalyzer)\n        .to(StackTraceAnalyzer)\n        .inSingletonScope();\n\n    // callee data extractors\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionDeclarationCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionExpressionCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(ObjectExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.ObjectExpressionCalleeDataExtractor);\n\n    // node transformers factory\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.Factory__ICalleeDataExtractor)\n        .toFactory<ICalleeDataExtractor>(InversifyContainerFacade\n            .getCacheFactory<CalleeDataExtractor, ICalleeDataExtractor>(\n                ServiceIdentifiers.ICalleeDataExtractor\n            ));\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/container/modules/analyzers/AnalyzersModule.ts","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class FunctionDeclarationCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return null;\n        }\n\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeUtils.getBlockScopesOfNode(blockScopeBody[0])[0],\n            callee.name\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isFunctionDeclarationNode(node) && node.id.name === name) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/analyzers/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor.ts","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class FunctionExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        if (NodeGuards.isIdentifierNode(callee)) {\n            calleeBlockStatement = this.getCalleeBlockStatement(\n                NodeUtils.getBlockScopesOfNode(blockScopeBody[0])[0],\n                callee.name\n            );\n        }\n\n        if (NodeGuards.isFunctionExpressionNode(callee)) {\n            calleeBlockStatement = callee.body;\n        }\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name || null\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isFunctionExpressionNode(node) &&\n                    parentNode &&\n                    NodeGuards.isVariableDeclaratorNode(parentNode) &&\n                    NodeGuards.isIdentifierNode(parentNode.id) &&\n                    parentNode.id.name === name\n                ) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/analyzers/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor.ts","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObjectMembersCallsChain } from '../../../types/analyzers/stack-trace-analyzer/TObjectMembersCallsChain';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ObjectExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {MemberExpression} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.MemberExpression): ICalleeData | null {\n        if (!NodeGuards.isMemberExpressionNode(callee)) {\n            return null;\n        }\n\n        const objectMembersCallsChain: TObjectMembersCallsChain = this.createObjectMembersCallsChain([], callee);\n\n        if (!objectMembersCallsChain.length) {\n            return null;\n        }\n\n        const functionExpressionName: string | number | null = objectMembersCallsChain[objectMembersCallsChain.length - 1];\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeUtils.getBlockScopesOfNode(blockScopeBody[0])[0],\n            objectMembersCallsChain\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: functionExpressionName\n        };\n    }\n\n    /**\n     * Creates array with MemberExpression calls chain.\n     *\n     * Example: object.foo.bar(); // ['object', 'foo', 'bar']\n     *\n     * @param {TObjectMembersCallsChain} currentChain\n     * @param {MemberExpression} memberExpression\n     * @returns {TObjectMembersCallsChain}\n     */\n    private createObjectMembersCallsChain (\n        currentChain: TObjectMembersCallsChain,\n        memberExpression: ESTree.MemberExpression\n    ): TObjectMembersCallsChain {\n        // first step: processing memberExpression `property` property\n        if (NodeGuards.isIdentifierNode(memberExpression.property) && memberExpression.computed === false) {\n            currentChain.unshift(memberExpression.property.name);\n        } else if (\n            NodeGuards.isLiteralNode(memberExpression.property) &&\n            (\n                typeof memberExpression.property.value === 'string' ||\n                typeof memberExpression.property.value === 'number'\n            )\n        ) {\n            currentChain.unshift(memberExpression.property.value);\n        } else {\n            return currentChain;\n        }\n\n        // second step: processing memberExpression `object` property\n        if (NodeGuards.isMemberExpressionNode(memberExpression.object)) {\n            return this.createObjectMembersCallsChain(currentChain, memberExpression.object);\n        } else if (NodeGuards.isIdentifierNode(memberExpression.object)) {\n            currentChain.unshift(memberExpression.object.name);\n        }\n\n        return currentChain;\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (\n        targetNode: ESTree.Node,\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const objectName: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!objectName) {\n            return null;\n        }\n\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isVariableDeclaratorNode(node) &&\n                    NodeGuards.isIdentifierNode(node.id) &&\n                    node.init &&\n                    NodeGuards.isObjectExpressionNode(node.init) &&\n                    node.id.name === objectName\n                ) {\n                    calleeBlockStatement = this.findCalleeBlockStatement(node.init.properties, objectMembersCallsChain);\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n\n    /**\n     * @param {Property[]} objectExpressionProperties\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private findCalleeBlockStatement (\n        objectExpressionProperties: ESTree.Property[],\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const nextItemInCallsChain: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!nextItemInCallsChain) {\n            return null;\n        }\n\n        for (const propertyNode of objectExpressionProperties) {\n            const isTargetPropertyNodeWithIdentifierKey: boolean =\n                NodeGuards.isIdentifierNode(propertyNode.key) && propertyNode.key.name === nextItemInCallsChain;\n            const isTargetPropertyNodeWithLiteralKey: boolean =\n                NodeGuards.isLiteralNode(propertyNode.key) &&\n                Boolean(propertyNode.key.value) &&\n                propertyNode.key.value === nextItemInCallsChain;\n\n            if (!isTargetPropertyNodeWithIdentifierKey && !isTargetPropertyNodeWithLiteralKey) {\n                continue;\n            }\n\n            if (NodeGuards.isObjectExpressionNode(propertyNode.value)) {\n                return this.findCalleeBlockStatement(propertyNode.value.properties, objectMembersCallsChain);\n            }\n\n            if (NodeGuards.isFunctionExpressionNode(propertyNode.value)) {\n                return propertyNode.value.body;\n            }\n        }\n\n        return null;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/analyzers/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TCalleeDataExtractorFactory } from '../../types/container/stack-trace-analyzer/TCalleeDataExtractorFactory';\n\nimport { ICalleeData } from '../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\nimport { IStackTraceAnalyzer } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { CalleeDataExtractor } from '../../enums/analyzers/stack-trace-analyzer/CalleeDataExtractor';\n\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * This class generates a data with a stack trace of functions calls\n *\n * For example:\n *\n * function Foo () {\n *     var baz = function () {\n *\n *     }\n *\n *     baz();\n * }\n *\n * foo();\n *\n * Will generate a structure like:\n *\n * [\n *      {\n *          callee: FOO_FUNCTION_NODE\n *          name: 'Foo',\n *          trace: [\n *              {\n *                  callee: BAZ_FUNCTION_NODE,\n *                  name: 'baz,\n *                  trace: []\n *              }\n *          ]\n *      }\n * ]\n */\n@injectable()\nexport class StackTraceAnalyzer implements IStackTraceAnalyzer {\n    /**\n     * @type {CalleeDataExtractor[]}\n     */\n    private static readonly calleeDataExtractorsList: CalleeDataExtractor[] = [\n        CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor,\n        CalleeDataExtractor.FunctionExpressionCalleeDataExtractor,\n        CalleeDataExtractor.ObjectExpressionCalleeDataExtractor\n    ];\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThresholdActivationLength: number = 25;\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThreshold: number = 0.002;\n\n    /**\n     * @type {TCalleeDataExtractorFactory}\n     */\n    private readonly calleeDataExtractorFactory: TCalleeDataExtractorFactory;\n\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICalleeDataExtractor) calleeDataExtractorFactory: TCalleeDataExtractorFactory\n    ) {\n        this.calleeDataExtractorFactory = calleeDataExtractorFactory;\n    }\n\n    /**\n     * @param {number} blockScopeBodyLength\n     * @returns {number}\n     */\n    public static getLimitIndex (blockScopeBodyLength: number): number {\n        const lastIndex: number = blockScopeBodyLength - 1;\n        const limitThresholdActivationIndex: number = StackTraceAnalyzer.limitThresholdActivationLength - 1;\n\n        let limitIndex: number = lastIndex;\n\n        if (lastIndex > limitThresholdActivationIndex) {\n            limitIndex = Math.round(\n                limitThresholdActivationIndex + (lastIndex * StackTraceAnalyzer.limitThreshold)\n            );\n\n            if (limitIndex > lastIndex) {\n                limitIndex = lastIndex;\n            }\n        }\n\n        return limitIndex;\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {IStackTraceData[]}\n     */\n    public analyze (astTree: ESTree.Program): IStackTraceData[] {\n        return this.analyzeRecursive(astTree.body);\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @returns {IStackTraceData[]}\n     */\n    private analyzeRecursive (blockScopeBody: ESTree.Node[]): IStackTraceData[] {\n        const limitIndex: number = StackTraceAnalyzer.getLimitIndex(blockScopeBody.length);\n        const stackTraceData: IStackTraceData[] = [];\n        const blockScopeBodyLength: number = blockScopeBody.length;\n\n        for (let index: number = 0; index < blockScopeBodyLength; index++) {\n            if (index > limitIndex) {\n                break;\n            }\n\n            const blockScopeBodyNode: ESTree.Node = blockScopeBody[index];\n\n            estraverse.traverse(blockScopeBodyNode, {\n                enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                    if (!NodeGuards.isCallExpressionNode(node)) {\n                        return;\n                    }\n\n                    if (blockScopeBodyNode.parentNode !== NodeUtils.getBlockScopesOfNode(node)[0]) {\n                        return estraverse.VisitorOption.Skip;\n                    }\n\n                    this.analyzeCallExpressionNode(stackTraceData, blockScopeBody, node);\n                }\n            });\n        }\n\n        return stackTraceData;\n    }\n\n    /**\n     * @param {IStackTraceData[]} stackTraceData\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {CallExpression} callExpressionNode\n     */\n    private analyzeCallExpressionNode (\n        stackTraceData: IStackTraceData[],\n        blockScopeBody: ESTree.Node[],\n        callExpressionNode: ESTree.CallExpression\n    ): void {\n        StackTraceAnalyzer.calleeDataExtractorsList.forEach((calleeDataExtractorName: CalleeDataExtractor) => {\n            const calleeData: ICalleeData | null = this.calleeDataExtractorFactory(calleeDataExtractorName)\n                .extract(blockScopeBody, callExpressionNode.callee);\n\n            if (!calleeData) {\n                return;\n            }\n\n            stackTraceData.push({\n                ...calleeData,\n                stackTrace: this.analyzeRecursive(calleeData.callee.body)\n            });\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/analyzers/stack-trace-analyzer/StackTraceAnalyzer.ts","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { ControlFlowReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BinaryExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer';\nimport { BlockStatementControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer';\nimport { CallExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer';\nimport { DeadCodeInjectionTransformer } from '../../../node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer';\nimport { FunctionControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/FunctionControlFlowTransformer';\nimport { LogicalExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer';\nimport { StringLiteralControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer';\n\nexport const controlFlowTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // control flow transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(BlockStatementControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.BlockStatementControlFlowTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(DeadCodeInjectionTransformer)\n        .whenTargetNamed(NodeTransformer.DeadCodeInjectionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionControlFlowTransformer);\n\n    // control flow replacers\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(BinaryExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.BinaryExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(CallExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.CallExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(LogicalExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.LogicalExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(StringLiteralControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.StringLiteralControlFlowReplacer);\n\n    // control flow replacer factory\n    bind<IControlFlowReplacer>(ServiceIdentifiers.Factory__IControlFlowReplacer)\n        .toFactory<IControlFlowReplacer>(InversifyContainerFacade\n            .getCacheFactory<ControlFlowReplacer, IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer));\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/container/modules/node-transformers/ControlFlowTransformersModule.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStorage } from '../../../interfaces/storages/IStorage';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\n\n@injectable()\nexport class BinaryExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryExpression} binaryExpressionNode\n     * @param {Node} parentNode\n     * @param {IStorage<ICustomNode>} controlFlowStorage\n     * @returns {Node}\n     */\n    public replace (\n        binaryExpressionNode: ESTree.BinaryExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: IStorage <ICustomNode>\n    ): ESTree.Node {\n        const replacerId: string = binaryExpressionNode.operator;\n        const binaryExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.BinaryExpressionFunctionNode\n        );\n\n        binaryExpressionFunctionCustomNode.initialize(replacerId);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            binaryExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            BinaryExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            binaryExpressionNode.left,\n            binaryExpressionNode.right\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.arrayUtils = arrayUtils;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static blockStatementHasProhibitedStatements (blockStatementNode: ESTree.BlockStatement): boolean {\n        return blockStatementNode.body.some((statement: ESTree.Statement) => {\n            const isBreakOrContinueStatement: boolean = NodeGuards.isBreakStatementNode(statement)\n                || NodeGuards.isContinueStatementNode(statement);\n            const isVariableDeclarationWithLetOrConstKind: boolean = NodeGuards.isVariableDeclarationNode(statement)\n                && (statement.kind === 'const' || statement.kind === 'let');\n            const isClassDeclaration: boolean = NodeGuards.isClassDeclarationNode(statement);\n\n            return NodeGuards.isFunctionDeclarationNode(statement)\n                || isBreakOrContinueStatement\n                || isVariableDeclarationWithLetOrConstKind\n                || isClassDeclaration;\n        });\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static canTransformBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        let canTransform: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isWhileStatementNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (\n                    NodeGuards.isBlockStatementNode(node)\n                    && BlockStatementControlFlowTransformer.blockStatementHasProhibitedStatements(node)\n                ) {\n                    canTransform = false;\n                }\n            }\n        });\n\n        if (blockStatementNode.body.length <= 4) {\n            canTransform = false;\n        }\n\n        return canTransform;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (blockStatementNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold ||\n            !BlockStatementControlFlowTransformer.canTransformBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const blockStatementBody: ESTree.Statement[] = blockStatementNode.body;\n        const originalKeys: number[] = this.arrayUtils.arrayRange(blockStatementBody.length);\n        const shuffledKeys: number[] = this.arrayUtils.arrayShuffle(originalKeys);\n        const originalKeysIndexesInShuffledArray: number[] = originalKeys.map((key: number) => shuffledKeys.indexOf(key));\n        const blockStatementControlFlowFlatteningCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode\n        );\n\n        blockStatementControlFlowFlatteningCustomNode.initialize(\n            blockStatementBody,\n            shuffledKeys,\n            originalKeysIndexesInShuffledArray\n        );\n\n        const newBlockStatementNode: TStatement = blockStatementControlFlowFlatteningCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStorage } from '../../../interfaces/storages/IStorage';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class CallExpressionControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {IStorage<ICustomNode>} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        callExpressionNode: ESTree.CallExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: IStorage <ICustomNode>\n    ): ESTree.Node {\n        const callee: ESTree.Expression = <ESTree.Expression>callExpressionNode.callee;\n\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return callExpressionNode;\n        }\n\n        const replacerId: string = String(callExpressionNode.arguments.length);\n        const callExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.CallExpressionFunctionNode\n        );\n        const expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[] = callExpressionNode.arguments;\n\n        callExpressionFunctionCustomNode.initialize(expressionArguments);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            callExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            CallExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            callee,\n            expressionArguments\n        );\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, callee, expressionArguments);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TDeadNodeInjectionCustomNodeFactory } from '../../types/container/custom-nodes/TDeadNodeInjectionCustomNodeFactory';\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\nimport { TNodeWithScope } from '../../types/node/TNodeWithScope';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ITransformersRunner } from '../../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { DeadCodeInjectionCustomNode } from '../../enums/custom-nodes/DeadCodeInjectionCustomNode';\nimport { NodeTransformer } from '../../enums/node-transformers/NodeTransformer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { Nodes } from '../../node/Nodes';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DeadCodeInjectionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string}\n     */\n    private static readonly deadCodeInjectionRootAstHostNodeName: string = 'deadCodeInjectionRootAstHostNode';\n\n    /**\n     * @type {number}\n     */\n    private static readonly maxNestedBlockStatementsCount: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly minCollectedBlockStatementsCount: number = 5;\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersToRenameBlockScopeIdentifiers: NodeTransformer[] = [\n        NodeTransformer.CatchClauseTransformer,\n        NodeTransformer.ClassDeclarationTransformer,\n        NodeTransformer.FunctionDeclarationTransformer,\n        NodeTransformer.FunctionTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.VariableDeclarationTransformer\n    ];\n\n    /**\n     * @type {Set <BlockStatement>}\n     */\n    private readonly deadCodeInjectionRootAstHostNodeSet: Set <ESTree.BlockStatement> = new Set();\n\n    /**\n     * @type {ESTree.BlockStatement[]}\n     */\n    private readonly collectedBlockStatements: ESTree.BlockStatement[] = [];\n\n    /**\n     * @type {number}\n     */\n    private collectedBlockStatementsTotalLength: number = 0;\n\n    /**\n     * @type {TDeadNodeInjectionCustomNodeFactory}\n     */\n    private readonly deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} deadCodeInjectionCustomNodeFactory\n     * @param {ITransformersRunner} transformersRunner\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n            deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory,\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.deadCodeInjectionCustomNodeFactory = deadCodeInjectionCustomNodeFactory;\n        this.transformersRunner = transformersRunner;\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isProhibitedNodeInsideCollectedBlockStatement (targetNode: ESTree.Node): boolean {\n        return NodeGuards.isBreakStatementNode(targetNode)\n            || NodeGuards.isContinueStatementNode(targetNode)\n            || NodeGuards.isAwaitExpressionNode(targetNode)\n            || NodeGuards.isSuperNode(targetNode);\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isScopeHoistingFunctionDeclaration (targetNode: ESTree.Node): boolean {\n        if (!NodeGuards.isFunctionDeclarationNode(targetNode)) {\n            return false;\n        }\n\n        const scopeNode: TNodeWithScope = NodeUtils.getScopeOfNode(targetNode);\n        const scopeBody: ESTree.Statement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? <ESTree.Statement[]>scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(targetNode);\n\n        if (indexInScope === 0) {\n            return false;\n        }\n\n        const slicedBody: ESTree.Statement[] = scopeBody.slice(0, indexInScope);\n        const hostBlockStatementNode: ESTree.BlockStatement = Nodes.getBlockStatementNode(slicedBody);\n        const functionDeclarationName: string = targetNode.id.name;\n\n        let isScopeHoistedFunctionDeclaration: boolean = false;\n\n        estraverse.traverse(hostBlockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isIdentifierNode(node) && node.name === functionDeclarationName) {\n                    isScopeHoistedFunctionDeclaration = true;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isScopeHoistedFunctionDeclaration;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidCollectedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let nestedBlockStatementsCount: number = 0;\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isBlockStatementNode(node)) {\n                    nestedBlockStatementsCount++;\n                }\n\n                if (\n                    nestedBlockStatementsCount > DeadCodeInjectionTransformer.maxNestedBlockStatementsCount\n                    || DeadCodeInjectionTransformer.isProhibitedNodeInsideCollectedBlockStatement(node)\n                    || DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)\n                ) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isValidBlockStatementNode;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidWrappedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        if (!isValidBlockStatementNode) {\n            return false;\n        }\n\n        const blockScopeOfBlockStatementNode: TNodeWithBlockScope = NodeUtils\n            .getBlockScopesOfNode(blockStatementNode)[0];\n\n        return blockScopeOfBlockStatementNode.type !== NodeType.Program;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.DeadCodeInjection:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n\n                            return node;\n                        }\n                    },\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.deadCodeInjectionRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isDeadCodeInjectionRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {NodeGuards} programNode\n     * @param {NodeGuards} parentNode\n     */\n    public analyzeNode (programNode: ESTree.Node, parentNode: ESTree.Node): void {\n        estraverse.traverse(programNode, {\n            enter: (node: ESTree.Node): void => {\n                if (!NodeGuards.isBlockStatementNode(node)) {\n                    return;\n                }\n\n                let clonedBlockStatementNode: ESTree.BlockStatement = NodeUtils.clone(node);\n\n                if (!DeadCodeInjectionTransformer.isValidCollectedBlockStatementNode(clonedBlockStatementNode)) {\n                    return;\n                }\n\n                /**\n                 * We should transform identifiers in the dead code block statement to avoid conflicts with original code\n                 */\n                NodeUtils.parentizeNode(clonedBlockStatementNode, clonedBlockStatementNode);\n                clonedBlockStatementNode = this.transformersRunner.transform(\n                    clonedBlockStatementNode,\n                    DeadCodeInjectionTransformer.transformersToRenameBlockScopeIdentifiers,\n                    TransformationStage.Obfuscating\n                );\n\n                this.collectedBlockStatements.push(clonedBlockStatementNode);\n            }\n        });\n\n        this.collectedBlockStatementsTotalLength = this.collectedBlockStatements.length;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards | VisitorOption}\n     */\n    public transformNode (\n        blockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.Node | estraverse.VisitorOption {\n        const canBreakTraverse: boolean = !this.collectedBlockStatements.length\n            || this.collectedBlockStatementsTotalLength < DeadCodeInjectionTransformer.minCollectedBlockStatementsCount;\n\n        if (canBreakTraverse) {\n            return estraverse.VisitorOption.Break;\n        }\n\n        if (\n            this.randomGenerator.getMathRandom() > this.options.deadCodeInjectionThreshold\n            || !DeadCodeInjectionTransformer.isValidWrappedBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const minInteger: number = 0;\n        const maxInteger: number = this.collectedBlockStatements.length - 1;\n        const randomIndex: number = this.randomGenerator.getRandomInteger(minInteger, maxInteger);\n        const randomBlockStatementNode: ESTree.BlockStatement = this.collectedBlockStatements.splice(randomIndex, 1)[0];\n        const isDuplicateBlockStatementNodes: boolean = randomBlockStatementNode === blockStatementNode;\n\n        if (isDuplicateBlockStatementNodes) {\n            return blockStatementNode;\n        }\n\n        return this.replaceBlockStatementNode(blockStatementNode, randomBlockStatementNode, parentNode);\n    }\n\n    /**\n     * @param {FunctionExpression} deadCodeInjectionRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (deadCodeInjectionRootAstHostNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        const hostNodeFirstStatement: ESTree.Statement = deadCodeInjectionRootAstHostNode.body[0];\n\n        if (!NodeGuards.isFunctionDeclarationNode(hostNodeFirstStatement)) {\n            throw new Error('Wrong dead code injection root AST host node. Host node should contain `FunctionDeclaration` node');\n        }\n\n        return hostNodeFirstStatement.body;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isDeadCodeInjectionRootAstHostNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return NodeGuards.isBlockStatementNode(node) && this.deadCodeInjectionRootAstHostNodeSet.has(node);\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} randomBlockStatementNode\n     * @param {Node} parentNode\n     * @returns {BlockStatement}\n     */\n    private replaceBlockStatementNode (\n        blockStatementNode: ESTree.BlockStatement,\n        randomBlockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.BlockStatement {\n        /**\n         * Should wrap original random block statement node into the parent block statement node (ast root host node)\n         * with function declaration node. This function declaration node will create block scope for all identifiers\n         * inside random block statement node and this identifiers won't affect identifiers of the rest AST tree.\n         */\n        const deadCodeInjectionRootAstHostNode: ESTree.BlockStatement = Nodes.getBlockStatementNode([\n            Nodes.getFunctionDeclarationNode(\n                DeadCodeInjectionTransformer.deadCodeInjectionRootAstHostNodeName,\n                [],\n                randomBlockStatementNode\n            )\n        ]);\n\n        /**\n         * Should store that host node and then extract random block statement node on the `finalizing` stage\n         */\n        this.deadCodeInjectionRootAstHostNodeSet.add(deadCodeInjectionRootAstHostNode);\n\n        const blockStatementDeadCodeInjectionCustomNode: ICustomNode = this.deadCodeInjectionCustomNodeFactory(\n            DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode\n        );\n\n        blockStatementDeadCodeInjectionCustomNode.initialize(blockStatementNode, deadCodeInjectionRootAstHostNode);\n\n        const newBlockStatementNode: ESTree.BlockStatement = <ESTree.BlockStatement>blockStatementDeadCodeInjectionCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowReplacerFactory } from '../../types/container/node-transformers/TControlFlowReplacerFactory';\nimport { TControlFlowStorageFactory } from '../../types/container/node-transformers/TControlFlowStorageFactory';\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IStorage } from '../../interfaces/storages/IStorage';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { ControlFlowReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class FunctionControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map <string, ControlFlowReplacer>}\n     */\n    private static readonly controlFlowReplacersMap: Map <string, ControlFlowReplacer> = new Map([\n        [NodeType.BinaryExpression, ControlFlowReplacer.BinaryExpressionControlFlowReplacer],\n        [NodeType.CallExpression, ControlFlowReplacer.CallExpressionControlFlowReplacer],\n        [NodeType.LogicalExpression, ControlFlowReplacer.LogicalExpressionControlFlowReplacer],\n        [NodeType.Literal, ControlFlowReplacer.StringLiteralControlFlowReplacer]\n    ]);\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMinDepth: number = 0;\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMaxDepth: number = 2;\n\n    /**\n     * @type {Map<ESTree.Node, IStorage<ICustomNode>>}\n     */\n    private readonly controlFlowData: Map <ESTree.Node, IStorage<ICustomNode>> = new Map();\n\n    /**\n     * @type {Set<ESTree.Function>}\n     */\n    private readonly visitedFunctionNodes: Set<ESTree.Function> = new Set();\n\n    /**\n     * @type {Set<TNodeWithBlockScope>}\n     */\n    private readonly hostNodesWithControlFlowNode: Set<TNodeWithBlockScope> = new Set();\n\n    /**\n     * @type {TControlFlowReplacerFactory}\n     */\n    private readonly controlFlowReplacerFactory: TControlFlowReplacerFactory;\n\n    /**\n     * @type {TControlFlowStorageFactory}\n     */\n    private readonly controlFlowStorageFactory: TControlFlowStorageFactory;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowStorageFactory} controlFlowStorageFactory\n     * @param {TControlFlowReplacerFactory} controlFlowReplacerFactory\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__TControlFlowStorage)\n            controlFlowStorageFactory: TControlFlowStorageFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowReplacer)\n            controlFlowReplacerFactory: TControlFlowReplacerFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowStorageFactory = controlFlowStorageFactory;\n        this.controlFlowReplacerFactory = controlFlowReplacerFactory;\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode && (\n                                NodeGuards.isFunctionDeclarationNode(node) ||\n                                NodeGuards.isFunctionExpressionNode(node) ||\n                                NodeGuards.isArrowFunctionExpressionNode(node)\n                            )\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {Function}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Function {\n        this.visitedFunctionNodes.add(functionNode);\n\n        if (!NodeGuards.isBlockStatementNode(functionNode.body)) {\n            return functionNode;\n        }\n\n        const hostNode: TNodeWithBlockScope = this.getHostNode(functionNode.body);\n        const controlFlowStorage: IStorage<ICustomNode> = this.getControlFlowStorage(hostNode);\n\n        this.controlFlowData.set(hostNode, controlFlowStorage);\n        this.transformFunctionBody(functionNode.body, controlFlowStorage);\n\n        if (!controlFlowStorage.getLength()) {\n            return functionNode;\n        }\n\n        const controlFlowStorageCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.ControlFlowStorageNode\n        );\n\n        controlFlowStorageCustomNode.initialize(controlFlowStorage);\n        NodeAppender.prependNode(hostNode, controlFlowStorageCustomNode.getNode());\n        this.hostNodesWithControlFlowNode.add(hostNode);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} hostNode\n     * @returns {IStorage<ICustomNode>}\n     */\n    private getControlFlowStorage (hostNode: TNodeWithBlockScope): IStorage<ICustomNode> {\n        const controlFlowStorage: IStorage <ICustomNode> = this.controlFlowStorageFactory();\n\n        if (this.controlFlowData.has(hostNode)) {\n            if (this.hostNodesWithControlFlowNode.has(hostNode)) {\n                hostNode.body.shift();\n            }\n\n            const hostControlFlowStorage: IStorage<ICustomNode> = <IStorage<ICustomNode>>this.controlFlowData.get(hostNode);\n\n            controlFlowStorage.mergeWith(hostControlFlowStorage, true);\n        }\n\n        return controlFlowStorage;\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @returns {TNodeWithBlockScope}\n     */\n    private getHostNode (functionNodeBody: ESTree.BlockStatement): TNodeWithBlockScope {\n        const blockScopesOfNode: TNodeWithBlockScope[] = NodeUtils.getBlockScopesOfNode(functionNodeBody);\n\n        if (blockScopesOfNode.length === 1) {\n            return functionNodeBody;\n        } else {\n            blockScopesOfNode.pop();\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMinDepth) {\n            blockScopesOfNode.splice(0, FunctionControlFlowTransformer.hostNodeSearchMinDepth);\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMaxDepth) {\n            blockScopesOfNode.length = FunctionControlFlowTransformer.hostNodeSearchMaxDepth;\n        }\n\n        return this.randomGenerator.getRandomGenerator().pickone(blockScopesOfNode);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private isVisitedFunctionNode (node: ESTree.Node): boolean {\n        return (\n            NodeGuards.isFunctionDeclarationNode(node) ||\n            NodeGuards.isFunctionExpressionNode(node) ||\n            NodeGuards.isArrowFunctionExpressionNode(node)\n        ) && this.visitedFunctionNodes.has(node);\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @param {IStorage<ICustomNode>} controlFlowStorage\n     */\n    private transformFunctionBody (functionNodeBody: ESTree.BlockStatement, controlFlowStorage: IStorage<ICustomNode>): void {\n        estraverse.replace(functionNodeBody, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | ESTree.Node => {\n                if (node.ignoredNode) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (this.isVisitedFunctionNode(node) || !parentNode) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (!FunctionControlFlowTransformer.controlFlowReplacersMap.has(node.type)) {\n                    return node;\n                }\n\n                if (this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold) {\n                    return node;\n                }\n\n                const controlFlowReplacerName: ControlFlowReplacer = <ControlFlowReplacer>FunctionControlFlowTransformer\n                    .controlFlowReplacersMap.get(node.type);\n\n                if (controlFlowReplacerName === undefined) {\n                    return node;\n                }\n\n                return {\n                    ...this.controlFlowReplacerFactory(controlFlowReplacerName).replace(node, parentNode, controlFlowStorage),\n                    parentNode\n                };\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/control-flow-transformers/FunctionControlFlowTransformer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStorage } from '../../../interfaces/storages/IStorage';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalExpression} logicalExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {IStorage<ICustomNode>} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        logicalExpressionNode: ESTree.LogicalExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: IStorage <ICustomNode>\n    ): ESTree.Node {\n        if (this.checkForProhibitedExpressions(logicalExpressionNode.left, logicalExpressionNode.right)) {\n            return logicalExpressionNode;\n        }\n\n        const replacerId: string = logicalExpressionNode.operator;\n        const logicalExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.LogicalExpressionFunctionNode\n        );\n\n        logicalExpressionFunctionCustomNode.initialize(replacerId);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            logicalExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            LogicalExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            logicalExpressionNode.left,\n            logicalExpressionNode.right\n        );\n    }\n\n    /**\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {boolean}\n     */\n    private checkForProhibitedExpressions (leftExpression: ESTree.Expression, rightExpression: ESTree.Expression): boolean {\n        return [leftExpression, rightExpression].some((expressionNode: ESTree.Node | ESTree.Expression): boolean => {\n            let nodeForCheck: ESTree.Node | ESTree.Expression;\n\n            if (!NodeGuards.isUnaryExpressionNode(expressionNode)) {\n                nodeForCheck = expressionNode;\n            } else {\n                nodeForCheck = NodeUtils.getUnaryExpressionArgumentNode(expressionNode);\n            }\n\n            return !NodeGuards.isLiteralNode(nodeForCheck) &&\n                !NodeGuards.isIdentifierNode(nodeForCheck) &&\n                !NodeGuards.isObjectExpressionNode(nodeForCheck) &&\n                !NodeGuards.isExpressionStatementNode(nodeForCheck);\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStorage } from '../../../interfaces/storages/IStorage';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class StringLiteralControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 1;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @param {IStorage<ICustomNode>} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        literalNode: ESTree.Literal,\n        parentNode: ESTree.Node,\n        controlFlowStorage: IStorage <ICustomNode>\n    ): ESTree.Node {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return literalNode;\n        }\n\n        if (typeof literalNode.value !== 'string' || literalNode.value.length < 3) {\n            return literalNode;\n        }\n\n        const replacerId: string = String(literalNode.value);\n        const literalFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.StringLiteralNode\n        );\n\n        literalFunctionCustomNode.initialize(literalNode.value);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            literalFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            StringLiteralControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(controlFlowStorage.getStorageId(), storageKey);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer.ts","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { MemberExpressionTransformer } from '../../../node-transformers/converting-transformers/MemberExpressionTransformer';\nimport { MethodDefinitionTransformer } from '../../../node-transformers/converting-transformers/MethodDefinitionTransformer';\nimport { ObjectExpressionKeysTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionKeysTransformer';\nimport { TemplateLiteralTransformer } from '../../../node-transformers/converting-transformers/TemplateLiteralTransformer';\n\nexport const convertingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // converting transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MemberExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.MemberExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MethodDefinitionTransformer)\n        .whenTargetNamed(NodeTransformer.MethodDefinitionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionKeysTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionKeysTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(TemplateLiteralTransformer)\n        .whenTargetNamed(NodeTransformer.TemplateLiteralTransformer);\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/container/modules/node-transformers/ConvertingTransformersModule.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class MemberExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMemberExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     *\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MemberExpression} memberExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (memberExpressionNode: ESTree.MemberExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (NodeGuards.isIdentifierNode(memberExpressionNode.property)) {\n            if (memberExpressionNode.computed) {\n                return memberExpressionNode;\n            }\n\n            memberExpressionNode.computed = true;\n            memberExpressionNode.property = {\n                type: NodeType.Literal,\n                value: memberExpressionNode.property.name,\n                raw: `'${memberExpressionNode.property.name}'`\n            };\n        }\n\n        return memberExpressionNode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/converting-transformers/MemberExpressionTransformer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     foo () { //... };\n *\n * on:\n *     ['foo'] { //... };\n *\n * Literal node will be obfuscated by LiteralTransformer\n */\n@injectable()\nexport class MethodDefinitionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly ignoredNames: string[] = ['constructor'];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMethodDefinitionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MethodDefinition} methodDefinitionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (methodDefinitionNode: ESTree.MethodDefinition, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            NodeGuards.isIdentifierNode(methodDefinitionNode.key) &&\n            !MethodDefinitionTransformer.ignoredNames.includes(methodDefinitionNode.key.name) &&\n            methodDefinitionNode.computed === false\n        ) {\n            methodDefinitionNode.computed = true;\n            methodDefinitionNode.key = {\n                type: NodeType.Literal,\n                value: methodDefinitionNode.key.name,\n                raw: `'${methodDefinitionNode.key.name}'`\n            };\n        }\n\n        return methodDefinitionNode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/converting-transformers/MethodDefinitionTransformer.ts","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithScope } from '../../types/node/TNodeWithScope';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { Nodes } from '../../node/Nodes';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class ObjectExpressionKeysTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map<VariableDeclarator, TNodeWithScope>}\n     */\n    private readonly cachedScopeNodesMap: Map <ESTree.VariableDeclarator, TNodeWithScope> = new Map();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TNodeWithScope} scopeNode\n     * @param {ExpressionStatement[]} expressionStatements\n     * @param {Node} variableDeclarator\n     */\n    private static appendExpressionStatements (\n        scopeNode: TNodeWithScope,\n        expressionStatements: ESTree.ExpressionStatement[],\n        variableDeclarator: ESTree.Node\n    ): void {\n        const variableDeclaration: ESTree.Node | undefined = variableDeclarator.parentNode;\n\n        if (!variableDeclaration || !NodeGuards.isVariableDeclarationNode(variableDeclaration)) {\n            throw new Error('Cannot find variable declaration for variable declarator');\n        }\n\n        NodeAppender.insertNodeAfter(scopeNode, expressionStatements, variableDeclaration);\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @param {number[]} removablePropertyIds\n     * @returns {Property[]}\n     */\n    private static filterObjectExpressionProperties (properties: ESTree.Property[], removablePropertyIds: number[]): ESTree.Property[] {\n        return properties.filter((property: ESTree.Property, index: number) => !removablePropertyIds.includes(index));\n    }\n\n    /**\n     * @param {Property} propertyNode\n     * @returns {string | null}\n     */\n    private static getPropertyNodeKeyName (propertyNode: ESTree.Property): string | null {\n        const propertyKeyNode: ESTree.Expression = propertyNode.key;\n\n        if (NodeGuards.isLiteralNode(propertyKeyNode) && typeof propertyKeyNode.value === 'string') {\n            return propertyKeyNode.value;\n        } else if (NodeGuards.isIdentifierNode(propertyKeyNode)) {\n            return propertyKeyNode.name;\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Expression | Pattern} propertyValueNode\n     * @returns {boolean}\n     */\n    private static isValidPropertyValueNode (propertyValueNode: ESTree.Expression | ESTree.Pattern): propertyValueNode is ESTree.Expression {\n        return !NodeGuards.isObjectPatternNode(propertyValueNode)\n        && !NodeGuards.isArrayPatternNode(propertyValueNode)\n        && !NodeGuards.isAssignmentPatternNode(propertyValueNode)\n        && !NodeGuards.isRestElementNode(propertyValueNode);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            this.options.transformObjectKeys\n                            && parentNode\n                            && NodeGuards.isObjectExpressionNode(node)\n                            && NodeGuards.isVariableDeclaratorNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     var object = {\n     *          foo: 1,\n     *          bar: 2\n     *     };\n     *\n     * on:\n     *     var object = {};\n     *     object['foo'] = 1;\n     *     object['bar'] = 2;\n     *\n     * @param {MemberExpression} objectExpressionNode\n     * @param {NodeGuards} variableDeclarator\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, variableDeclarator: ESTree.VariableDeclarator): ESTree.Node {\n        // should pass only Expression nodes as MemberExpression.object value\n        if (!NodeGuards.isIdentifierNode(variableDeclarator.id)) {\n            return objectExpressionNode;\n        }\n\n        const scopeNode: TNodeWithScope | null = NodeUtils.getScopeOfNode(variableDeclarator);\n\n        if (!scopeNode || !NodeGuards.isNodeHasScope(scopeNode)) {\n            return objectExpressionNode;\n        }\n\n        this.cachedScopeNodesMap.set(variableDeclarator, scopeNode);\n\n        return this.transformObjectExpressionNode(\n            objectExpressionNode,\n            variableDeclarator.id,\n            variableDeclarator\n        );\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @param {Expression} memberExpressionObject\n     * @param {VariableDeclarator} variableDeclarator\n     * @returns {[ExpressionStatement[] , number[]]}\n     */\n    private extractPropertiesToExpressionStatements (\n        properties: ESTree.Property[],\n        memberExpressionObject: ESTree.Expression,\n        variableDeclarator: ESTree.VariableDeclarator\n    ): [ESTree.ExpressionStatement[], number[]] {\n        const propertiesLength: number = properties.length;\n        const expressionStatements: ESTree.ExpressionStatement[] = [];\n        const removablePropertyIds: number[] = [];\n\n        for (let i: number = 0; i < propertiesLength; i++) {\n            const property: ESTree.Property = properties[i];\n            const propertyValue: ESTree.Expression | ESTree.Pattern = property.value;\n\n            // invalid property nodes\n            if (!ObjectExpressionKeysTransformer.isValidPropertyValueNode(propertyValue)) {\n                continue;\n            }\n\n            /**\n             * Stage 1: extract property node key names\n             */\n            const propertyKeyName: string | null = ObjectExpressionKeysTransformer.getPropertyNodeKeyName(property);\n\n            if (!propertyKeyName) {\n                continue;\n            }\n\n            /**\n             * Stage 2: creating new expression statement node with member expression based on removed property\n             */\n            const shouldCreateLiteralNode: boolean = !property.computed\n                || (property.computed && NodeGuards.isLiteralNode(property.key));\n            const memberExpressionProperty: ESTree.Expression = shouldCreateLiteralNode\n                ? Nodes.getLiteralNode(propertyKeyName)\n                : Nodes.getIdentifierNode(propertyKeyName);\n            const memberExpressionNode: ESTree.MemberExpression = Nodes\n                .getMemberExpressionNode(memberExpressionObject, memberExpressionProperty, true);\n            const expressionStatementNode: ESTree.ExpressionStatement = Nodes.getExpressionStatementNode(\n                Nodes.getAssignmentExpressionNode('=', memberExpressionNode, propertyValue)\n            );\n\n            /**\n             * Stage 3: recursively processing nested object expressions\n             */\n            if (NodeGuards.isObjectExpressionNode(property.value)) {\n                this.transformObjectExpressionNode(property.value, memberExpressionNode, variableDeclarator);\n            }\n\n            /**\n             * Stage 4: filling arrays\n             */\n            expressionStatements.push(expressionStatementNode);\n            removablePropertyIds.push(i);\n        }\n\n        return [expressionStatements, removablePropertyIds];\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Expression} memberExpressionObjectNode\n     * @param {VariableDeclarator} variableDeclarator\n     * @returns {Node}\n     */\n    private transformObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        memberExpressionObjectNode: ESTree.Expression,\n        variableDeclarator: ESTree.VariableDeclarator\n    ): ESTree.Node {\n        const properties: ESTree.Property[] = objectExpressionNode.properties;\n\n        if (!properties.length) {\n            return objectExpressionNode;\n        }\n\n        const scopeNode: TNodeWithScope | undefined = this.cachedScopeNodesMap.get(variableDeclarator);\n\n        if (!scopeNode) {\n            return objectExpressionNode;\n        }\n\n        const [expressionStatements, removablePropertyIds]: [ESTree.ExpressionStatement[], number[]] = this\n            .extractPropertiesToExpressionStatements(properties, memberExpressionObjectNode, variableDeclarator);\n\n        objectExpressionNode.properties = ObjectExpressionKeysTransformer\n            .filterObjectExpressionProperties(properties, removablePropertyIds);\n        ObjectExpressionKeysTransformer\n            .appendExpressionStatements(scopeNode, expressionStatements, variableDeclarator);\n\n        return objectExpressionNode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/converting-transformers/ObjectExpressionKeysTransformer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeWithScope } from '../../types/node/TNodeWithScope';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { Nodes } from '../../node/Nodes';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * Transform ES2015 template literals to ES5\n * Thanks to Babel for algorithm\n */\n@injectable()\nexport class TemplateLiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private static isLiteralNodeWithStringValue (node: ESTree.Node): boolean {\n        return node && NodeGuards.isLiteralNode(node) && typeof node.value === 'string';\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isReturnStatementNode(node) && node.argument === null) {\n                            return this.fixEsprimaReturnStatementTemplateLiteralNode(node);\n                        }\n                    },\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isTemplateLiteralNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {TemplateLiteral} templateLiteralNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (templateLiteralNode: ESTree.TemplateLiteral, parentNode: ESTree.Node): ESTree.Node {\n        const templateLiteralExpressions: ESTree.Expression[] = templateLiteralNode.expressions;\n\n        let nodes: ESTree.Expression[] = [];\n\n        templateLiteralNode.quasis.forEach((templateElement: ESTree.TemplateElement) => {\n            nodes.push(Nodes.getLiteralNode(templateElement.value.cooked));\n\n            const expression: ESTree.Expression | undefined = templateLiteralExpressions.shift();\n\n            if (!expression) {\n                return;\n            }\n\n            nodes.push(expression);\n        });\n\n        nodes = nodes.filter((node: ESTree.Literal | ESTree.Expression) => {\n            return !(NodeGuards.isLiteralNode(node) && node.value === '');\n        });\n\n        // since `+` is left-to-right associative\n        // ensure the first node is a string if first/second isn't\n        if (\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[0]) &&\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[1])\n        ) {\n            nodes.unshift(Nodes.getLiteralNode(''));\n        }\n\n        if (nodes.length > 1) {\n            let root: ESTree.BinaryExpression = Nodes.getBinaryExpressionNode(\n                '+',\n                <ESTree.Literal>nodes.shift(),\n                <ESTree.Expression>nodes.shift()\n            );\n\n            nodes.forEach((node: ESTree.Literal | ESTree.Expression) => {\n                root = Nodes.getBinaryExpressionNode('+', root, <ESTree.Literal | ESTree.Expression>node);\n            });\n\n            return root;\n        }\n\n        return nodes[0];\n    }\n\n    /**\n     * @param {ReturnStatement} returnStatementNode\n     * @returns {Node | VisitorOption}\n     */\n    private fixEsprimaReturnStatementTemplateLiteralNode (returnStatementNode: ESTree.ReturnStatement): ESTree.Node | void {\n        const scopeNode: TNodeWithScope = NodeUtils.getScopeOfNode(returnStatementNode);\n        const scopeBody: TStatement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(returnStatementNode);\n\n        // in incorrect AST-tree return statement node should be penultimate\n        if (indexInScope !== scopeBody.length - 2) {\n            return;\n        }\n\n        const nextSiblingStatementNode: TStatement | null = scopeBody[indexInScope + 1];\n\n        if (!nextSiblingStatementNode || !NodeGuards.isExpressionStatementNode(nextSiblingStatementNode)) {\n            return;\n        }\n\n        let isSiblingStatementHasTemplateLiteralNode: boolean = false;\n\n        estraverse.traverse(nextSiblingStatementNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void | estraverse.VisitorOption => {\n                if (!NodeGuards.isTemplateLiteralNode(node)) {\n                    return;\n                }\n\n                isSiblingStatementHasTemplateLiteralNode = true;\n\n                return estraverse.VisitorOption.Break;\n            }\n        });\n\n        if (!isSiblingStatementHasTemplateLiteralNode) {\n            return;\n        }\n\n        returnStatementNode.argument = nextSiblingStatementNode.expression;\n        scopeBody.pop();\n\n        if (!NodeGuards.isSwitchCaseNode(scopeNode)) {\n            scopeNode.body = [...scopeBody];\n        } else {\n            scopeNode.consequent = <ESTree.Statement[]>[...scopeBody];\n        }\n\n        return returnStatementNode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/converting-transformers/TemplateLiteralTransformer.ts","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../../../interfaces/custom-nodes/ICustomNodeGroup';\n\nimport { ControlFlowCustomNode } from \"../../../enums/custom-nodes/ControlFlowCustomNode\";\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { CustomNodeGroup } from '../../../enums/custom-nodes/CustomNodeGroup';\nimport { DeadCodeInjectionCustomNode } from '../../../enums/custom-nodes/DeadCodeInjectionCustomNode';\n\nimport { ConsoleOutputCustomNodeGroup } from '../../../custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup';\nimport { DebugProtectionCustomNodeGroup } from '../../../custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup';\nimport { DomainLockCustomNodeGroup } from '../../../custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup';\nimport { SelfDefendingCustomNodeGroup } from '../../../custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup';\nimport { StringArrayCustomNodeGroup } from '../../../custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup';\n\nimport { BinaryExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode';\nimport { BlockStatementControlFlowFlatteningNode } from '../../../custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode';\nimport { BlockStatementDeadCodeInjectionNode } from '../../../custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode';\nimport { CallExpressionControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode';\nimport { CallExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode';\nimport { ControlFlowStorageNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode';\nimport { ConsoleOutputDisableExpressionNode } from '../../../custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode';\nimport { DebugProtectionFunctionCallNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode';\nimport { DebugProtectionFunctionIntervalNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode';\nimport { DebugProtectionFunctionNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode';\nimport { DomainLockNode } from '../../../custom-nodes/domain-lock-nodes/DomainLockNode';\nimport { ExpressionWithOperatorControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode';\nimport { LogicalExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode';\nimport { NodeCallsControllerFunctionNode } from '../../../custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode';\nimport { SelfDefendingUnicodeNode } from '../../../custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode';\nimport { StringArrayCallsWrapper } from '../../../custom-nodes/string-array-nodes/StringArrayCallsWrapper';\nimport { StringArrayNode } from '../../../custom-nodes/string-array-nodes/StringArrayNode';\nimport { StringArrayRotateFunctionNode } from '../../../custom-nodes/string-array-nodes/StringArrayRotateFunctionNode';\nimport { StringLiteralControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode';\nimport { StringLiteralNode } from '../../../custom-nodes/control-flow-flattening-nodes/StringLiteralNode';\n\nexport const customNodesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // custom nodes\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(ConsoleOutputDisableExpressionNode)\n        .whenTargetNamed(CustomNode.ConsoleOutputDisableExpressionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionCallNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionCallNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionIntervalNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionIntervalNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DomainLockNode)\n        .whenTargetNamed(CustomNode.DomainLockNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(NodeCallsControllerFunctionNode)\n        .whenTargetNamed(CustomNode.NodeCallsControllerFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(SelfDefendingUnicodeNode)\n        .whenTargetNamed(CustomNode.SelfDefendingUnicodeNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayCallsWrapper)\n        .whenTargetNamed(CustomNode.StringArrayCallsWrapper);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayNode)\n        .whenTargetNamed(CustomNode.StringArrayNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayRotateFunctionNode)\n        .whenTargetNamed(CustomNode.StringArrayRotateFunctionNode);\n\n    // control flow custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BinaryExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.BinaryExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementControlFlowFlatteningNode)\n        .whenTargetNamed(ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ControlFlowStorageNode)\n        .whenTargetNamed(ControlFlowCustomNode.ControlFlowStorageNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ExpressionWithOperatorControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(LogicalExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.LogicalExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode);\n\n    // dead code injection custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementDeadCodeInjectionNode)\n        .whenTargetNamed(DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode);\n\n    // node groups\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(ConsoleOutputCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.ConsoleOutputCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DebugProtectionCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DebugProtectionCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DomainLockCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DomainLockCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(SelfDefendingCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.SelfDefendingCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(StringArrayCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.StringArrayCustomNodeGroup);\n\n    // customNode factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__ICustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getFactory<CustomNode, ICustomNode>(ServiceIdentifiers.ICustomNode));\n\n    // control flow customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<ControlFlowCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions\n            ));\n\n    // dead code injection customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<DeadCodeInjectionCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions\n            ));\n\n    // customNodeGroup factory\n    bind<ICustomNodeGroup>(ServiceIdentifiers.Factory__ICustomNodeGroup)\n        .toFactory<ICustomNodeGroup>(InversifyContainerFacade\n            .getFactory<CustomNodeGroup, ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup));\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/container/modules/custom-nodes/CustomNodesModule.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class ConsoleOutputCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // consoleOutputDisableExpressionNode append\n        this.appendCustomNodeIfExist(CustomNode.ConsoleOutputDisableExpressionNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNodeToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockScope;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prependNode(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.disableConsoleOutput) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const consoleOutputDisableExpressionNode: ICustomNode = this.customNodeFactory(CustomNode.ConsoleOutputDisableExpressionNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        consoleOutputDisableExpressionNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.ConsoleOutputDisableExpressionNode, consoleOutputDisableExpressionNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class DebugProtectionCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // debugProtectionFunctionCallNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionCallNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNodeToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // debugProtectionFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNode(blockScopeNode, customNode.getNode());\n        });\n\n        // debugProtectionFunctionIntervalNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionIntervalNode, (customNode: ICustomNode) => {\n            const programBodyLength: number = blockScopeNode.body.length;\n            const randomIndex: number = this.randomGenerator.getRandomInteger(0, programBodyLength);\n\n            NodeAppender.insertNodeAtIndex(blockScopeNode, customNode.getNode(), randomIndex);\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockScope;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prependNode(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.debugProtection) {\n            return;\n        }\n\n        const debugProtectionFunctionName: string = this.identifierNamesGenerator.generate();\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const debugProtectionFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionNode);\n        const debugProtectionFunctionCallNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionCallNode);\n        const debugProtectionFunctionIntervalNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionIntervalNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        debugProtectionFunctionNode.initialize(debugProtectionFunctionName);\n        debugProtectionFunctionCallNode.initialize(debugProtectionFunctionName, callsControllerFunctionName);\n        debugProtectionFunctionIntervalNode.initialize(debugProtectionFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DebugProtectionFunctionNode, debugProtectionFunctionNode);\n        this.customNodes.set(CustomNode.DebugProtectionFunctionCallNode, debugProtectionFunctionCallNode);\n\n        if (this.options.debugProtectionInterval) {\n            this.customNodes.set(CustomNode.DebugProtectionFunctionIntervalNode, debugProtectionFunctionIntervalNode);\n        }\n\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class DomainLockCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // domainLockNode append\n        this.appendCustomNodeIfExist(CustomNode.DomainLockNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNodeToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockScope;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prependNode(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.domainLock.length) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const domainLockNode: ICustomNode = this.customNodeFactory(CustomNode.DomainLockNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        domainLockNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DomainLockNode, domainLockNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class SelfDefendingCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // selfDefendingUnicodeNode append\n        this.appendCustomNodeIfExist(CustomNode.SelfDefendingUnicodeNode, (customNode: ICustomNode) => {\n            NodeAppender.appendNodeToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockScope;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prependNode(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.selfDefending) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const selfDefendingUnicodeNode: ICustomNode = this.customNodeFactory(CustomNode.SelfDefendingUnicodeNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        selfDefendingUnicodeNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.SelfDefendingUnicodeNode, selfDefendingUnicodeNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\nimport { IStorage } from '../../../interfaces/storages/IStorage';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class StringArrayCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {IStorage <string>}\n     */\n    private readonly stringArrayStorage: IStorage <string>;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {IStorage<string>} stringArrayStorage\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: IStorage<string>,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n        this.stringArrayStorage = stringArrayStorage;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        if (!this.stringArrayStorage.getLength()) {\n            return;\n        }\n\n        // stringArrayNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayNode, (customNode: ICustomNode) => {\n            NodeAppender.prependNode(blockScopeNode, customNode.getNode());\n        });\n\n        // stringArrayCallsWrapper append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayCallsWrapper, (customNode: ICustomNode) => {\n            NodeAppender.insertNodeAtIndex(blockScopeNode, customNode.getNode(), 1);\n        });\n\n        // stringArrayRotateFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayRotateFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.insertNodeAtIndex(blockScopeNode, customNode.getNode(), 1);\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.stringArray) {\n            return;\n        }\n\n        const stringArrayNode: ICustomNode = this.customNodeFactory(CustomNode.StringArrayNode);\n        const stringArrayCallsWrapper: ICustomNode = this.customNodeFactory(CustomNode.StringArrayCallsWrapper);\n        const stringArrayRotateFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.StringArrayRotateFunctionNode);\n\n        const stringArrayStorageId: string = this.stringArrayStorage.getStorageId();\n\n        const [stringArrayName, stringArrayCallsWrapperName]: string[] = stringArrayStorageId.split('|');\n\n        let stringArrayRotateValue: number;\n\n        if (this.options.rotateStringArray) {\n            stringArrayRotateValue = this.randomGenerator.getRandomInteger(100, 500);\n        } else {\n            stringArrayRotateValue = 0;\n        }\n\n        stringArrayNode.initialize(this.stringArrayStorage, stringArrayName, stringArrayRotateValue);\n        stringArrayCallsWrapper.initialize(stringArrayName, stringArrayCallsWrapperName);\n        stringArrayRotateFunctionNode.initialize(stringArrayName, stringArrayRotateValue);\n\n        this.customNodes.set(CustomNode.StringArrayNode, stringArrayNode);\n        this.customNodes.set(CustomNode.StringArrayCallsWrapper, stringArrayCallsWrapper);\n\n        if (this.options.rotateStringArray) {\n            this.customNodes.set(CustomNode.StringArrayRotateFunctionNode, stringArrayRotateFunctionNode);\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { Nodes } from '../../node/Nodes';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BinaryExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {BinaryOperator}\n     */\n    @initializable()\n    private operator!: BinaryOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     */\n    public initialize (operator: BinaryOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = Nodes.getExpressionStatementNode(\n            Nodes.getFunctionExpressionNode(\n                [\n                    Nodes.getIdentifierNode('x'),\n                    Nodes.getIdentifierNode('y')\n                ],\n                Nodes.getBlockStatementNode([\n                    Nodes.getReturnStatementNode(\n                        Nodes.getBinaryExpressionNode(\n                            this.operator,\n                            Nodes.getIdentifierNode('x'),\n                            Nodes.getIdentifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode.ts","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate1 (): string {\n    return `\n        var that;\n        \n        try {\n            var getGlobal = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');');\n            \n            that = getGlobal();\n        } catch (e) {\n            that = window;\n        }\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/GlobalVariableTemplate1.ts","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate2 (): string {\n    return `\n        var getGlobal = function () {\n            var globalObject;\n        \n            try {\n                globalObject = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');')();\n            } catch (e) {\n                globalObject = window;\n            }\n            \n            return globalObject;\n        };\n        var that = getGlobal();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/GlobalVariableTemplate2.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { Nodes } from '../../node/Nodes';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowFlatteningNode extends AbstractCustomNode {\n    /**\n     * @type {ESTree.Statement[]}\n     */\n    @initializable()\n    private blockStatementBody!: ESTree.Statement[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private originalKeysIndexesInShuffledArray!: number[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private shuffledKeys!: number[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {Statement[]} blockStatementBody\n     * @param {number[]} shuffledKeys\n     * @param {number[]} originalKeysIndexesInShuffledArray\n     */\n    public initialize (\n        blockStatementBody: ESTree.Statement[],\n        shuffledKeys: number[],\n        originalKeysIndexesInShuffledArray: number[]\n    ): void {\n        this.blockStatementBody = blockStatementBody;\n        this.shuffledKeys = shuffledKeys;\n        this.originalKeysIndexesInShuffledArray = originalKeysIndexesInShuffledArray;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const controllerIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const indexIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const structure: ESTree.BlockStatement = Nodes.getBlockStatementNode([\n            Nodes.getVariableDeclarationNode([\n                Nodes.getVariableDeclaratorNode(\n                    Nodes.getIdentifierNode(controllerIdentifierName),\n                    Nodes.getCallExpressionNode(\n                        Nodes.getMemberExpressionNode(\n                            Nodes.getLiteralNode(\n                                this.originalKeysIndexesInShuffledArray.join('|')\n                            ),\n                            Nodes.getIdentifierNode('split')\n                        ),\n                        [\n                            Nodes.getLiteralNode('|')\n                        ]\n                    )\n                ),\n                Nodes.getVariableDeclaratorNode(\n                    Nodes.getIdentifierNode(indexIdentifierName),\n                    Nodes.getLiteralNode(0)\n                )\n            ]),\n            Nodes.getWhileStatementNode(\n                Nodes.getLiteralNode(true),\n                Nodes.getBlockStatementNode([\n                    Nodes.getSwitchStatementNode(\n                        Nodes.getMemberExpressionNode(\n                            Nodes.getIdentifierNode(controllerIdentifierName),\n                            Nodes.getUpdateExpressionNode(\n                                '++',\n                                Nodes.getIdentifierNode(indexIdentifierName)\n                            ),\n                            true\n                        ),\n                        this.shuffledKeys.map((key: number, index: number) => {\n                            const statement: ESTree.Statement = this.blockStatementBody[key];\n                            const consequent: ESTree.Statement[] = [statement];\n\n                            /**\n                             * We shouldn't add continue statement after return statement\n                             * to prevent `unreachable code after return statement` warnings\n                             */\n                            if (!NodeGuards.isReturnStatementNode(statement)) {\n                                consequent.push(Nodes.getContinueStatement());\n                            }\n\n                            return Nodes.getSwitchCaseNode(\n                                Nodes.getLiteralNode(String(index)),\n                                consequent\n                            );\n                        })\n                    ),\n                    Nodes.getBreakStatement()\n                ])\n            )\n        ]);\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator, BlockStatement } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { Nodes } from '../../node/Nodes';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementDeadCodeInjectionNode extends AbstractCustomNode {\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private blockStatementNode!: BlockStatement;\n\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private deadCodeInjectionRootAstHostNode!: BlockStatement;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} deadCodeInjectionRootAstHostNode\n     */\n    public initialize (\n        blockStatementNode: BlockStatement,\n        deadCodeInjectionRootAstHostNode: BlockStatement\n    ): void {\n        this.blockStatementNode = blockStatementNode;\n        this.deadCodeInjectionRootAstHostNode = deadCodeInjectionRootAstHostNode;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const random1: boolean = this.randomGenerator.getMathRandom() > 0.5;\n        const random2: boolean = this.randomGenerator.getMathRandom() > 0.5;\n\n        const operator: BinaryOperator = random1 ? '===' : '!==';\n        const leftString: string = this.randomGenerator.getRandomString(5);\n        const rightString: string = random2 ? leftString : this.randomGenerator.getRandomString(5);\n\n        const [consequent, alternate]: [BlockStatement, BlockStatement] = random1 === random2\n            ? [this.blockStatementNode, this.deadCodeInjectionRootAstHostNode]\n            : [this.deadCodeInjectionRootAstHostNode, this.blockStatementNode];\n\n        const structure: BlockStatement = Nodes.getBlockStatementNode([\n            Nodes.getIfStatementNode(\n                Nodes.getBinaryExpressionNode(\n                    operator,\n                    Nodes.getLiteralNode(leftString),\n                    Nodes.getLiteralNode(rightString)\n                ),\n                consequent,\n                alternate\n            )\n        ]);\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\nimport { Expression } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from \"../../../interfaces/utils/IRandomGenerator\";\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { Nodes } from '../../../node/Nodes';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private callee!: Expression;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        callee: Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.callee = callee;\n        this.expressionArguments = expressionArguments;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = Nodes.getExpressionStatementNode(\n            Nodes.getCallExpressionNode(\n                Nodes.getMemberExpressionNode(\n                    Nodes.getIdentifierNode(this.controlFlowStorageName),\n                    Nodes.getIdentifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.callee,\n                    ...this.expressionArguments\n                ]\n            )\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { Nodes } from '../../node/Nodes';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]): void {\n        this.expressionArguments = expressionArguments;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const calleeIdentifier: ESTree.Identifier = Nodes.getIdentifierNode('callee');\n        const params: ESTree.Identifier[] = [];\n        const argumentsLength: number = this.expressionArguments.length;\n\n        for (let i: number = 0; i < argumentsLength; i++) {\n            params.push(Nodes.getIdentifierNode(`param${i + 1}`));\n        }\n\n        const structure: TStatement = Nodes.getExpressionStatementNode(\n            Nodes.getFunctionExpressionNode(\n                [\n                    calleeIdentifier,\n                    ...params\n                ],\n                Nodes.getBlockStatementNode([\n                    Nodes.getReturnStatementNode(\n                        Nodes.getCallExpressionNode(\n                            calleeIdentifier,\n                            params\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStorage } from '../../../interfaces/storages/IStorage';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { Nodes } from '../../../node/Nodes';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ControlFlowStorageNode extends AbstractCustomNode {\n    /**\n     * @type {IStorage <ICustomNode>}\n     */\n    @initializable()\n    private controlFlowStorage!: IStorage <ICustomNode>;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {IStorage<ICustomNode>} controlFlowStorage\n     */\n    public initialize (controlFlowStorage: IStorage <ICustomNode>): void {\n        this.controlFlowStorage = controlFlowStorage;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const propertyNodes: ESTree.Property[] = Array\n            .from<[string, ICustomNode]>(this.controlFlowStorage.getStorage())\n            .map(([key, value]: [string, ICustomNode]) => {\n                const node: ESTree.Node = value.getNode()[0];\n\n                if (!NodeGuards.isExpressionStatementNode(node)) {\n                    throw new Error('Function node for control flow storage object should be passed inside the `ExpressionStatement` node!');\n                }\n\n                return Nodes.getPropertyNode(\n                    Nodes.getIdentifierNode(key),\n                    node.expression\n                );\n            });\n\n        let structure: ESTree.Node = Nodes.getVariableDeclarationNode([\n            Nodes.getVariableDeclaratorNode(\n                Nodes.getIdentifierNode(this.controlFlowStorage.getStorageId()),\n                Nodes.getObjectExpressionNode(propertyNodes)\n            )\n        ]);\n\n        structure = NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { ConsoleOutputDisableExpressionTemplate } from '../../templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class ConsoleOutputDisableExpressionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.Extension\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return format(ConsoleOutputDisableExpressionTemplate(), {\n            consoleLogDisableFunctionName: this.identifierNamesGenerator.generate(),\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode.ts","/**\n * @returns {string}\n */\nexport function ConsoleOutputDisableExpressionTemplate (): string {\n    return `\n        var {consoleLogDisableFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func = function () {};\n            \n            {globalVariableTemplate}\n                        \n            if (!that.console) {\n                that.console = (function (func){\n                    var c = {};\n                    \n                    c.log = func;\n                    c.warn = func;\n                    c.debug = func;\n                    c.info = func;\n                    c.error = func;\n                    c.exception = func;\n                    c.trace = func;\n                    \n                    return c;\n                })(func);\n            } else {\n                that.console.log = func;\n                that.console.warn = func;\n                that.console.debug = func;\n                that.console.info = func;\n                that.console.error = func;\n                that.console.exception = func;\n                that.console.trace = func;\n            }\n        });\n        \n        {consoleLogDisableFunctionName}();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionCallTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string, callsControllerFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionCallTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode.ts","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionCallTemplate (): string {\n    return `\n        (function () {\n            {singleNodeCallControllerFunctionName}(this, function () {\n                var regExp1 = new RegExp('function *\\\\\\\\( *\\\\\\\\)');\n                var regExp2 = new RegExp('\\\\\\\\+\\\\\\\\+ *\\\\(?:_0x(?:[a-f0-9]){4,6}|(?:\\\\\\\\b|\\\\\\\\d)[a-z0-9]{1,4}(?:\\\\\\\\b|\\\\\\\\d)\\\\)', 'i');\n       \n                var result = {debugProtectionFunctionName}('init');\n                \n                if (!regExp1.test(result + 'chain') || !regExp2.test(result + 'input')) {\n                    result('0');\n                } else {\n                    {debugProtectionFunctionName}();\n                }\n            })();\n        })();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionIntervalTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionIntervalNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionIntervalTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode.ts","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionIntervalTemplate (): string {\n    return `\n        setInterval(function () {\n            {debugProtectionFunctionName}();\n        }, 4000);\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebuggerTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate';\nimport { DebuggerTemplateNoEval } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval';\nimport { DebugProtectionFunctionTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const debuggerTemplate: string = this.options.target !== ObfuscationTarget.Extension\n            ? DebuggerTemplate()\n            : DebuggerTemplateNoEval();\n\n        return format(DebugProtectionFunctionTemplate(), {\n            debuggerTemplate,\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode.ts","/**\n * @returns {string}\n */\nexport function DebuggerTemplate (): string {\n    return `\n        if (typeof counter === 'string') {\n            return (function (arg) {}.constructor('while (true) {}').apply('counter'));\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                (function () {return true;}.constructor('debu' + 'gger').call('action'));\n            } else {\n                (function () {return false;}.constructor('debu' + 'gger').apply('stateObject'));\n            }\n            \n        }\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate.ts","/**\n * @returns {string}\n */\nexport function DebuggerTemplateNoEval (): string {\n    return `\n        if (typeof counter === 'string') {\n            var func = function () {\n                while (true) {}\n            };\n            \n            return func();\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                debugger;\n            } else {\n                debugger;\n            }\n            \n        }\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval.ts","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionTemplate (): string {\n    return `\n        function {debugProtectionFunctionName} (ret) {\n            function debuggerProtection (counter) {\n            \n                {debuggerTemplate}\n                \n                debuggerProtection(++counter);\n            }\n            \n            try {\n                if (ret) {\n                    return debuggerProtection;\n                } else {\n                    debuggerProtection(0);\n                }\n            } catch (y) {}\n        }\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { ICryptUtils } from '../../interfaces/utils/ICryptUtils';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DomainLockNodeTemplate } from '../../templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DomainLockNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.cryptUtils = cryptUtils;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const domainsString: string = this.options.domainLock.join(';');\n        const [hiddenDomainsString, diff]: string[] = this.cryptUtils.hideString(\n            domainsString,\n            domainsString.length * 3\n        );\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.Extension\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return format(DomainLockNodeTemplate(), {\n            domainLockFunctionName: this.identifierNamesGenerator.generate(),\n            diff: diff,\n            domains: hiddenDomainsString,\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/domain-lock-nodes/DomainLockNode.ts","/**\n * @returns {string}\n */\nexport function DomainLockNodeTemplate (): string {\n    return `\n        var {domainLockFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            \n            {globalVariableTemplate}\n            \n            var func = function () {\n                return {\n                    key: 'item',\n                    value: 'attribute',\n                    getAttribute: function () {\n                        for (var i = 0; i < 1000; i--) {\n                            var isPositive = i > 0;\n                            \n                            switch (isPositive) {\n                                case true:\n                                    return this.item + '_' + this.value + '_' + i;\n                                default:\n                                    this.item + '_' + this.value;\n                            }\n                        }\n                    }()\n                };\n            };\n                        \n            var regExp = new RegExp(\"[{diff}]\", \"g\");\n            var domains = \"{domains}\".replace(regExp, \"\").split(\";\");\n            var document;\n            var domain;\n                        \n            for (var d in that) {\n                if (d.length == 8 && d.charCodeAt(7) == 116 && d.charCodeAt(5) == 101 && d.charCodeAt(3) == 117 && d.charCodeAt(0) == 100) {\n                    document = d;\n                \n                    break;\n                }\n            }\n\n            for (var d1 in that[document]) {\n                if (d1.length == 6 && d1.charCodeAt(5) == 110 && d1.charCodeAt(0) == 100) {\n                    domain = d1;\n                    \n                    break;\n                }\n            }\n            \n            if ((!document && !domain) || (!that[document] && !that[document][domain])) {\n                return;\n            }\n            \n            var currentDomain = that[document][domain];\n\n            var ok = false;\n                        \n            for (var i = 0; i < domains.length; i++) {\n                var domain = domains[i];\n                var position = currentDomain.length - domain.length;\n                var lastIndex = currentDomain.indexOf(domain, position);\n                var endsWith = lastIndex !== -1 && lastIndex === position;\n                \n                if (endsWith) {\n                    if (currentDomain.length == domain.length || domain.indexOf(\".\") === 0) {\n                        ok = true;\n                    }\n                    \n                    break;\n                }\n            }\n               \n            if (!ok) {\n                data;\n            } else {\n                return;\n            }\n            \n            func();\n        });\n\n        {domainLockFunctionName}();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { Expression } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { Nodes } from '../../../node/Nodes';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ExpressionWithOperatorControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private leftValue!: Expression;\n\n    /**\n     * @type {ESTree.Expression}\n     */\n    @initializable()\n    private rightValue!: Expression;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} leftValue\n     * @param {Expression} rightValue\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        leftValue: Expression,\n        rightValue: Expression,\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.leftValue = leftValue;\n        this.rightValue = rightValue;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = Nodes.getExpressionStatementNode(\n            Nodes.getCallExpressionNode(\n                Nodes.getMemberExpressionNode(\n                    Nodes.getIdentifierNode(this.controlFlowStorageName),\n                    Nodes.getIdentifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.leftValue,\n                    this.rightValue\n                ]\n            )\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { LogicalOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { Nodes } from '../../node/Nodes';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {LogicalOperator}\n     */\n    @initializable()\n    private operator!: LogicalOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     */\n    public initialize (operator: LogicalOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = Nodes.getExpressionStatementNode(\n            Nodes.getFunctionExpressionNode(\n                [\n                    Nodes.getIdentifierNode('x'),\n                    Nodes.getIdentifierNode('y')\n                ],\n                Nodes.getBlockStatementNode([\n                    Nodes.getReturnStatementNode(\n                        Nodes.getLogicalExpressionNode(\n                            this.operator,\n                            Nodes.getIdentifierNode('x'),\n                            Nodes.getIdentifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { SingleNodeCallControllerTemplate } from '../../templates/SingleNodeCallControllerTemplate';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class NodeCallsControllerFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ObfuscationEvent}\n     */\n    @initializable()\n    private appendEvent!: ObfuscationEvent;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {ObfuscationEvent} appendEvent\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (appendEvent: ObfuscationEvent, callsControllerFunctionName: string): void {\n        this.appendEvent = appendEvent;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        if (this.appendEvent === ObfuscationEvent.AfterObfuscation) {\n            return JavaScriptObfuscator.obfuscate(\n                format(SingleNodeCallControllerTemplate(), {\n                    singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n                }),\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    identifierNamesGenerator: this.options.identifierNamesGenerator,\n                    seed: this.options.seed\n                }\n            ).getObfuscatedCode();\n        }\n\n        return format(SingleNodeCallControllerTemplate(), {\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode.ts","/**\n * @returns {string}\n */\nexport function SingleNodeCallControllerTemplate (): string {\n    return `\n        var {singleNodeCallControllerFunctionName} = (function(){\n            var firstCall = true;\n            \n            return function (context, fn){\n                var rfn = firstCall ? function(){\n                    if(fn){\n                        var res = fn.apply(context, arguments);\n                        fn = null;\n                        return res;\n                    }\n                } : function(){}\n                \n                firstCall = false;\n                \n                return rfn;\n            }\n        })();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/SingleNodeCallControllerTemplate.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class SelfDefendingUnicodeNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return JavaScriptObfuscator.obfuscate(\n            format(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                selfDefendingFunctionName: this.identifierNamesGenerator.generate(),\n                singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed,\n                unicodeEscapeSequence: true\n            }\n        ).getObfuscatedCode();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode.ts","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enters code in infinity loop.\n * Notice, that second and third call to recursiveFunc1('indexOf') has cyrillic `` character instead latin\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        var {selfDefendingFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func1 = function(){return 'dev';},\n                func2 = function () {\n                    return 'window';\n                };\n                \n            var test1 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return !regExp.test(func1.toString());\n            };\n            \n            var test2 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`(\\\\\\\\[x|u](\\\\w){2,4})+`, true)\n                }');\n                \n                return regExp.test(func2.toString());\n            };\n            \n            var recursiveFunc1 = function (string) {\n                var i = ~-1 >> 1 + 255 % 0;\n                                \n                if (string.indexOf('i' === i)) {\n                    recursiveFunc2(string)\n                }\n            };\n            \n            var recursiveFunc2 = function (string) {\n                var i = ~-4 >> 1 + 255 % 0;\n                \n                if (string.indexOf((true+\"\")[3]) !== i) {\n                    recursiveFunc1(string)\n                }\n            };\n            \n            if (!test1()) {\n                if (!test2()) {\n                    recursiveFunc1('indxOf');\n                } else {\n                    recursiveFunc1('indexOf');\n                }\n            } else {\n                recursiveFunc1('indxOf');\n            }\n        })\n        \n        {selfDefendingFunctionName}();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AtobTemplate } from '../../templates/AtobTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\nimport { Rc4Template } from '../../templates/Rc4Template';\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate';\nimport { StringArrayBase64DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate';\nimport { StringArrayCallsWrapperTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate';\nimport { StringArrayRc4DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class StringArrayCallsWrapper extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayCallsWrapperName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {string} stringArrayCallsWrapperName\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayCallsWrapperName: string\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayCallsWrapperName = stringArrayCallsWrapperName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const decodeNodeTemplate: string = this.getDecodeStringArrayTemplate();\n\n        return JavaScriptObfuscator.obfuscate(\n            format(StringArrayCallsWrapperTemplate(), {\n                decodeNodeTemplate,\n                stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                stringArrayName: this.stringArrayName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    private getDecodeStringArrayTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.Extension\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n        const atobPolyfill: string = format(AtobTemplate(), { globalVariableTemplate });\n\n        let decodeStringArrayTemplate: string = '';\n        let selfDefendingCode: string = '';\n\n        if (this.options.selfDefending) {\n            selfDefendingCode = format(\n                SelfDefendingTemplate(\n                    this.randomGenerator,\n                    this.escapeSequenceEncoder\n                ),\n                {\n                    stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                    stringArrayName: this.stringArrayName\n                }\n            );\n        }\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                decodeStringArrayTemplate = format(\n                    StringArrayRc4DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        rc4Polyfill: Rc4Template(),\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                decodeStringArrayTemplate = format(\n                    StringArrayBase64DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n\n                break;\n        }\n\n        return decodeStringArrayTemplate;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/string-array-nodes/StringArrayCallsWrapper.ts","/**\n * @returns {string}\n */\nexport function AtobTemplate (): string {\n    return `\n        (function () {\n            {globalVariableTemplate}\n            \n            var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n            that.atob || (\n                that.atob = function(input) {\n                    var str = String(input).replace(/=+$/, '');\n                    for (\n                        var bc = 0, bs, buffer, idx = 0, output = '';\n                        buffer = str.charAt(idx++);\n                        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n                            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n                    ) {\n                        buffer = chars.indexOf(buffer);\n                    }\n                return output;\n            });\n        })();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/AtobTemplate.ts","/**\n * @returns {string}\n */\nexport function Rc4Template (): string {\n    return `\n        var rc4 = function (str, key) {\n            var s = [], j = 0, x, res = '', newStr = '';\n           \n            str = atob(str);\n                \n            for (var k = 0, length = str.length; k < length; k++) {\n                newStr += '%' + ('00' + str.charCodeAt(k).toString(16)).slice(-2);\n            }\n        \n            str = decodeURIComponent(newStr);\n                    \t        \n\t        for (var i = 0; i < 256; i++) {\n                s[i] = i;\n            }\n \n            for (i = 0; i < 256; i++) {\n                j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n            }\n            \n            i = 0;\n            j = 0;\n            \n            for (var y = 0; y < str.length; y++) {\n                i = (i + 1) % 256;\n                j = (j + s[i]) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n                res += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n            }\n                      \n            return res;\n        }\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/Rc4Template.ts","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n * @constructor\n */\nexport function SelfDefendingTemplate (\n    randomGenerator: IRandomGenerator,\n    escapeSequenceEncoder: IEscapeSequenceEncoder\n): string {\n    const identifierLength: number = 6;\n    const rc4BytesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const statesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const newStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const firstStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const secondStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const checkStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const runStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const getStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const stateResultIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    \n    return `\n        var StatesClass = function (${rc4BytesIdentifier}) {\n            this.${rc4BytesIdentifier} = ${rc4BytesIdentifier};\n            this.${statesIdentifier} = [1, 0, 0];\n            this.${newStateIdentifier} = function(){return 'newState';};\n            this.${firstStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *`, true)\n            }';\n            this.${secondStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`['|\"].+['|\"];? *}`, true)\n            }';\n        };\n        \n        StatesClass.prototype.${checkStateIdentifier} = function () {\n            var regExp = new RegExp(this.${firstStateIdentifier} + this.${secondStateIdentifier});\n            var expression = regExp.test(this.${newStateIdentifier}.toString())\n                ? --this.${statesIdentifier}[1]\n                : --this.${statesIdentifier}[0];\n            \n            return this.${runStateIdentifier}(expression);\n        };\n        \n        StatesClass.prototype.${runStateIdentifier} = function (${stateResultIdentifier}) {\n            if (!Boolean(~${stateResultIdentifier})) {\n                return ${stateResultIdentifier};\n            }\n            \n            return this.${getStateIdentifier}(this.${rc4BytesIdentifier});\n        };\n\n        StatesClass.prototype.${getStateIdentifier} = function (${rc4BytesIdentifier}) {\n            for (var i = 0, len = this.${statesIdentifier}.length; i < len; i++) {\n                this.${statesIdentifier}.push(Math.round(Math.random()));\n                len = this.${statesIdentifier}.length;\n            }\n            \n            return ${rc4BytesIdentifier}(this.${statesIdentifier}[0]);\n        };\n\n        new StatesClass({stringArrayCallsWrapperName}).${checkStateIdentifier}();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate.ts","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayBase64DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const base64DecodeFunctionIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n\n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier} = function (str) {\n                var string = atob(str);\n                var newStringChars = [];\n                \n                for (var i = 0, length = string.length; i < length; i++) {\n                    newStringChars += '%' + ('00' + string.charCodeAt(i).toString(16)).slice(-2);\n                }\n                \n                return decodeURIComponent(newStringChars);\n            };\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n                  \n        var cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n                        \n        if (cachedValue === undefined) {\n            {selfDefendingCode}\n            \n            value = {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier}(value);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate.ts","/**\n * @returns {string}\n */\nexport function StringArrayCallsWrapperTemplate (): string {\n    return `\n        var {stringArrayCallsWrapperName} = function (index, key) {\n            index = index - 0;\n            \n            var value = {stringArrayName}[index];\n            \n            {decodeNodeTemplate}\n        \n            return value;\n        };\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate.ts","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayRc4DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const rc4Identifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const onceIdentifier: string = randomGenerator.getRandomString(identifierLength);\n  \n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {rc4Polyfill}\n            {stringArrayCallsWrapperName}.${rc4Identifier} = rc4;\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n  \n        var cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n\n        if (cachedValue === undefined) {\n            if ({stringArrayCallsWrapperName}.${onceIdentifier} === undefined) {\n                {selfDefendingCode}\n                \n                {stringArrayCallsWrapperName}.${onceIdentifier} = true;\n            }\n            \n            value = {stringArrayCallsWrapperName}.${rc4Identifier}(value, key);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IStorage } from '../../interfaces/storages/IStorage';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { StringArrayTemplate } from '../../templates/string-array-nodes/string-array-node/StringArrayTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { StringArrayStorage } from '../../storages/string-array/StringArrayStorage';\n\n@injectable()\nexport class StringArrayNode extends AbstractCustomNode {\n    /**\n     * @type {IStorage <string>}\n     */\n    @initializable()\n    private stringArrayStorage!: IStorage <string>;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {number}\n     */\n    @initializable()\n    private stringArrayRotateValue!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {IStorage<string>} stringArrayStorage\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayStorage: IStorage <string>,\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayStorage = stringArrayStorage;\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        (<StringArrayStorage>this.stringArrayStorage).rotateArray(this.stringArrayRotateValue);\n\n        return super.getNode();\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(StringArrayTemplate(), {\n            stringArrayName: this.stringArrayName,\n            stringArray: this.stringArrayStorage.toString()\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/string-array-nodes/StringArrayNode.ts","/**\n * @returns {string}\n */\nexport function StringArrayTemplate (): string {\n    return `\n        var {stringArrayName} = [{stringArray}];\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/string-array-nodes/string-array-node/StringArrayTemplate.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate';\nimport { StringArrayRotateFunctionTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { Utils } from '../../utils/Utils';\n\n@injectable()\nexport class StringArrayRotateFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @param {number}\n     */\n    @initializable()\n    private stringArrayRotateValue!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const timesName: string = this.identifierNamesGenerator.generate();\n        const whileFunctionName: string = this.identifierNamesGenerator.generate();\n\n        let code: string = '';\n\n        if (this.options.selfDefending) {\n            code = format(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                timesName,\n                whileFunctionName\n            });\n        } else {\n            code = `${whileFunctionName}(++${timesName})`;\n        }\n\n        return JavaScriptObfuscator.obfuscate(\n            format(StringArrayRotateFunctionTemplate(), {\n                code,\n                timesName,\n                stringArrayName: this.stringArrayName,\n                stringArrayRotateValue: Utils.decToHex(this.stringArrayRotateValue),\n                whileFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/string-array-nodes/StringArrayRotateFunctionNode.ts","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enter code in infinity loop.\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        var selfDefendingFunc = function () {\n            var object = {\n                data: {\n                    key: 'cookie',\n                    value: 'timeout'\n                },\n                setCookie: function (options, name, value, document) {\n                    document = document || {};\n                    \n                    var updatedCookie = name + \"=\" + value;\n\n                    var i = 0;\n                                                            \n                    for (var i = 0, len = options.length; i < len; i++) {\n                        var propName = options[i];\n                                     \n                        updatedCookie += \"; \" + propName;\n                        \n                        var propValue = options[propName];\n                        \n                        options.push(propValue);\n                        len = options.length;\n                                                                        \n                        if (propValue !== true) {\n                            updatedCookie += \"=\" + propValue;\n                        }\n                    }\n\n                    document['cookie'] = updatedCookie;\n                },\n                removeCookie: function(){return 'dev';},\n                getCookie: function (document, name) {\n                    document = document || function (value) { return value };\n                    var matches = document(new RegExp(\n                        \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n                    ));\n                    \n                    var func = function (param1, param2) {\n                        param1(++param2);\n                    };\n                    \n                    func({whileFunctionName}, {timesName});\n                                        \n                    return matches ? decodeURIComponent(matches[1]) : undefined;\n                }\n            };\n            \n            var test1 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return regExp.test(object.removeCookie.toString());\n            };\n            \n            object['updateCookie'] = test1;\n            \n            var cookie = '';\n            var result = object['updateCookie']();\n                                    \n            if (!result) {\n                object['setCookie'](['*'], 'counter', 1);\n            } else if (result) {\n                cookie = object['getCookie'](null, 'counter');\n            } else {\n                object['removeCookie']();\n            }\n        };\n        \n        selfDefendingFunc();\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate.ts","/**\n * @returns {string}\n */\nexport function StringArrayRotateFunctionTemplate (): string {\n    return `\n        (function (array, {timesName}) {\n            var {whileFunctionName} = function (times) {\n                while (--times) {\n                    array['push'](array['shift']());\n                }\n            };\n            \n            {code}\n        })({stringArrayName}, 0x{stringArrayRotateValue});\n    `;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate.ts","export enum JSFuck {\n    False = '![]',\n    True = '!![]',\n\n    a = '(false+\"\")[1]',\n    b = '([][\"entries\"]()+\"\")[2]',\n    c = '([][\"fill\"]+\"\")[3]',\n    d = '(undefined+\"\")[2]',\n    e = '(true+\"\")[3]',\n    f = '(false+\"\")[0]',\n    g = '(false+[0]+String)[20]',\n    h = '(+(101))[\"toString\"](21)[1]',\n    i = '([false]+undefined)[10]',\n    j = '([][\"entries\"]()+\"\")[3]',\n    k = '(+(20))[\"toString\"](21)',\n    l = '(false+\"\")[2]',\n    m = '(Number+\"\")[11]',\n    n = '(undefined+\"\")[1]',\n    o = '(true+[][\"fill\"])[10]',\n    p = '(+(211))[\"toString\"](31)[1]',\n    q = '(+(212))[\"toString\"](31)[1]',\n    r = '(true+\"\")[1]',\n    s = '(false+\"\")[3]',\n    t = '(true+\"\")[0]',\n    u = '(undefined+\"\")[0]',\n    v = '(+(31))[\"toString\"](32)',\n    w = '(+(32))[\"toString\"](33)',\n    x = '(+(101))[\"toString\"](34)[1]',\n    y = '(NaN+[Infinity])[10]',\n    z = '(+(35))[\"toString\"](36)',\n\n    A = '(+[]+Array)[10]',\n    B = '(+[]+Boolean)[10]',\n    C = 'Function(\"return escape\")()((\"\")[\"italics\"]())[2]',\n    D = 'Function(\"return escape\")()([][\"fill\"])[\"slice\"](\"-1\")',\n    E = '(RegExp+\"\")[12]',\n    F = '(+[]+Function)[10]',\n    G = '(false+Function(\"return Date\")()())[30]',\n    H = '\\'H\\'',\n    I = '(Infinity+\"\")[0]',\n    J = '\\'J\\'',\n    K = '\\'K\\'',\n    L = '\\'L\\'',\n    M = '(true+Function(\"return Date\")()())[30]',\n    N = '(NaN+\"\")[0]',\n    O = '(NaN+Function(\"return{}\")())[11]',\n    P = '\\'P\\'',\n    Q = '\\'Q\\'',\n    R = '(+[]+RegExp)[10]',\n    S = '(+[]+String)[10]',\n    T = '(NaN+Function(\"return Date\")()())[30]',\n    U = '(NaN+Function(\"return{}\")()[\"toString\"][\"call\"]())[11]',\n    V = '\\'V\\'',\n    W = '\\'W\\'',\n    X = '\\'X\\'',\n    Y = '\\'Y\\'',\n    Z = '\\'Z\\'',\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/JSFuck.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { Nodes } from '../../../node/Nodes';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class StringLiteralControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = Nodes.getExpressionStatementNode(\n            Nodes.getMemberExpressionNode(\n                Nodes.getIdentifierNode(this.controlFlowStorageName),\n                Nodes.getIdentifierNode(this.controlFlowStorageKey)\n            )\n        );\n\n        NodeUtils.parentize(structure);\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { Nodes } from '../../node/Nodes';\n\n@injectable()\nexport class StringLiteralNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private literalValue!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} literalValue\n     */\n    public initialize (literalValue: string): void {\n        this.literalValue = literalValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = Nodes.getExpressionStatementNode(\n            Nodes.getLiteralNode(this.literalValue)\n        );\n\n        return [structure];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom-nodes/control-flow-flattening-nodes/StringLiteralNode.ts","import { ContainerModule, interfaces } from 'inversify';\n\nexport const finalizingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // finalizing transformers\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/container/modules/node-transformers/FinalizingTransformersModule.ts","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { IdentifierNamesGenerator } from '../../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\n\nimport { HexadecimalIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator';\nimport { MangledIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/MangledIdentifierNamesGenerator';\n\nexport const generatorsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // identifier name generators\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(HexadecimalIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator);\n\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(MangledIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.MangledIdentifierNamesGenerator);\n\n    // identifier name generator factory\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n        .toFactory<IIdentifierNamesGenerator>((context: interfaces.Context): (options: IOptions) => IIdentifierNamesGenerator => {\n            let cachedIdentifierNamesGenerator: IIdentifierNamesGenerator | null = null;\n\n            return (options: IOptions) => {\n                if (cachedIdentifierNamesGenerator) {\n                    return cachedIdentifierNamesGenerator;\n                }\n\n                let identifierNamesGenerator: IIdentifierNamesGenerator;\n\n                switch (options.identifierNamesGenerator) {\n                    case IdentifierNamesGenerator.MangledIdentifierNamesGenerator:\n                        identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                            ServiceIdentifiers.IIdentifierNamesGenerator,\n                            IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n                        );\n\n                        break;\n\n                    case IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator:\n                    default:\n                        identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                            ServiceIdentifiers.IIdentifierNamesGenerator,\n                            IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator\n                        );\n                }\n\n                cachedIdentifierNamesGenerator = identifierNamesGenerator;\n\n                return identifierNamesGenerator;\n            };\n        });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/container/modules/generators/GeneratorsModule.ts","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\nimport { Utils } from '../../utils/Utils';\n\n@injectable()\nexport class HexadecimalIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {number}\n     */\n    private static readonly baseIdentifierNameLength: number = 6;\n\n    /**\n     * @type {Set<string>}\n     */\n    private readonly randomVariableNameSet: Set <string> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generate (): string {\n        const rangeMinInteger: number = 10000;\n        const rangeMaxInteger: number = 99_999_999;\n        const randomInteger: number = this.randomGenerator.getRandomInteger(rangeMinInteger, rangeMaxInteger);\n        const hexadecimalNumber: string = Utils.decToHex(randomInteger);\n        const baseIdentifierName: string = hexadecimalNumber.substr(0, HexadecimalIdentifierNamesGenerator.baseIdentifierNameLength);\n        const identifierName: string = `_${Utils.hexadecimalPrefix}${baseIdentifierName}`;\n\n        if (this.randomVariableNameSet.has(identifierName)) {\n            return this.generate();\n        }\n\n        this.randomVariableNameSet.add(identifierName);\n\n        return identifierName;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generateWithPrefix (): string {\n        const identifierName: string = this.generate();\n\n        return `${this.options.identifiersPrefix}${identifierName}`.replace('__', '_');\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.ts","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\n\n@injectable()\nexport class MangledIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {string}\n     */\n    private static readonly initMangledNameCharacter: string = '9';\n\n    /**\n     * @type {string[]}\n     */\n    private static readonly nameSequence: string[] = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n\n    /**\n     * Reserved JS words with length of 2-4 symbols that can be possible generated with this replacer\n     *\n     * @type {string[]}\n     */\n    private static readonly reservedNames: string[] = [\n        'byte', 'case', 'char', 'do', 'else', 'enum', 'eval', 'for', 'goto',\n        'if', 'in', 'int', 'let', 'long', 'new', 'null', 'this', 'true', 'try',\n        'var', 'void', 'with'\n    ];\n\n    /**\n     * @type {string}\n     */\n    private previousMangledName: string = MangledIdentifierNamesGenerator.initMangledNameCharacter;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {string} previousMangledName\n     * @returns {string}\n     */\n    private static generateNewMangledName (previousMangledName: string): string {\n        const generateNewMangledName: (name: string) => string = (name: string): string => {\n            const nameSequence: string[] = MangledIdentifierNamesGenerator.nameSequence;\n            const nameLength: number = name.length;\n\n            const zeroSequence: (num: number) => string = (num: number): string => {\n                return '0'.repeat(num);\n            };\n\n            let index: number = nameLength - 1;\n\n            do {\n                const character: string = name.charAt(index);\n                const indexInSequence: number = nameSequence.indexOf(character);\n                const lastNameSequenceIndex: number = nameSequence.length - 1;\n\n                if (indexInSequence !== lastNameSequenceIndex) {\n                    const previousNamePart: string = name.substring(0, index);\n                    const nextCharacter: string = nameSequence[indexInSequence + 1];\n                    const zeroSequenceLength: number = nameLength - (index + 1);\n                    const zeroSequenceCharacters: string = zeroSequence(zeroSequenceLength);\n\n                    return previousNamePart + nextCharacter + zeroSequenceCharacters;\n                }\n\n                --index;\n            } while (index >= 0);\n\n            return `a${zeroSequence(nameLength)}`;\n        };\n\n        let newMangledName: string = generateNewMangledName(previousMangledName);\n\n        if (!MangledIdentifierNamesGenerator.validateMangledName(newMangledName)) {\n            newMangledName = MangledIdentifierNamesGenerator.generateNewMangledName(newMangledName);\n        }\n\n        return newMangledName;\n    }\n\n    /**\n     * @param {string} mangledName\n     * @returns {boolean}\n     */\n    private static validateMangledName (mangledName: string): boolean {\n        return !MangledIdentifierNamesGenerator.reservedNames.includes(mangledName);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generate (): string {\n        const identifierName: string = MangledIdentifierNamesGenerator.generateNewMangledName(this.previousMangledName);\n\n        this.previousMangledName = identifierName;\n\n        return identifierName;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generateWithPrefix (): string {\n        const prefix: string = this.options.identifiersPrefix ?\n            `${this.options.identifiersPrefix}_`\n            : '';\n        const identifierName: string = this.generate();\n\n        return `${prefix}${identifierName}`;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/generators/identifier-names-generators/MangledIdentifierNamesGenerator.ts","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nexport const nodeTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // node transformers factory\n    bind<INodeTransformer>(ServiceIdentifiers.Factory__INodeTransformer)\n        .toFactory<INodeTransformer>(InversifyContainerFacade\n            .getCacheFactory<NodeTransformer, INodeTransformer>(ServiceIdentifiers.INodeTransformer));\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/container/modules/node-transformers/NodeTransformersModule.ts","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\n\nimport { IdentifierObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { LiteralObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BaseIdentifierObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer';\nimport { BooleanLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer';\nimport { CatchClauseTransformer } from '../../../node-transformers/obfuscating-transformers/CatchClauseTransformer';\nimport { ClassDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/ClassDeclarationTransformer';\nimport { FunctionDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionDeclarationTransformer';\nimport { FunctionTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionTransformer';\nimport { LabeledStatementTransformer } from '../../../node-transformers/obfuscating-transformers/LabeledStatementTransformer';\nimport { LiteralTransformer } from '../../../node-transformers/obfuscating-transformers/LiteralTransformer';\nimport { NumberLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer';\nimport { ObjectExpressionTransformer } from '../../../node-transformers/obfuscating-transformers/ObjectExpressionTransformer';\nimport { StringLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer';\nimport { VariableDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/VariableDeclarationTransformer';\n\nexport const obfuscatingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // obfuscating transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CatchClauseTransformer)\n        .whenTargetNamed(NodeTransformer.CatchClauseTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ClassDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.ClassDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LabeledStatementTransformer)\n        .whenTargetNamed(NodeTransformer.LabeledStatementTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LiteralTransformer)\n        .whenTargetNamed(NodeTransformer.LiteralTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(VariableDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.VariableDeclarationTransformer);\n\n    // literal obfuscating replacers\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(BooleanLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(NumberLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(StringLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer);\n\n    // identifier obfuscating replacers\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.IIdentifierObfuscatingReplacer)\n        .to(BaseIdentifierObfuscatingReplacer)\n        .whenTargetNamed(IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer);\n\n    // literal obfuscating replacer factory\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n        .toFactory<IObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<LiteralObfuscatingReplacer, IObfuscatingReplacer>(\n                ServiceIdentifiers.IObfuscatingReplacer\n            ));\n\n    // identifier obfuscating replacer factory\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n        .toFactory<IIdentifierObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<IdentifierObfuscatingReplacer, IIdentifierObfuscatingReplacer>(\n                ServiceIdentifiers.IIdentifierObfuscatingReplacer\n            ));\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/container/modules/node-transformers/ObfuscatingTransformersModule.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../../types/container/generators/TIdentifierNamesGeneratorFactory';\n\nimport { IIdentifierNamesGenerator } from '../../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IIdentifierObfuscatingReplacer } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { Nodes } from '../../../../node/Nodes';\n\n@injectable()\nexport class BaseIdentifierObfuscatingReplacer extends AbstractObfuscatingReplacer implements IIdentifierObfuscatingReplacer {\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly namesMap: Map<string, string> = new Map();\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @param {number} nodeIdentifier\n     * @returns {Identifier}\n     */\n    public replace (nodeValue: string, nodeIdentifier: number): ESTree.Identifier {\n        const mapKey: string = `${nodeValue}-${String(nodeIdentifier)}`;\n\n        if (this.namesMap.has(mapKey)) {\n            nodeValue = <string>this.namesMap.get(mapKey);\n        }\n\n        return Nodes.getIdentifierNode(nodeValue);\n    }\n\n    /**\n     * Store `nodeName` of global identifiers as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {string} nodeName\n     * @param {number} nodeIdentifier\n     */\n    public storeGlobalName (nodeName: string, nodeIdentifier: number): void {\n        if (this.isReservedName(nodeName)) {\n            return;\n        }\n\n        const identifierName: string = this.identifierNamesGenerator.generateWithPrefix();\n\n        this.namesMap.set(`${nodeName}-${String(nodeIdentifier)}`, identifierName);\n    }\n\n    /**\n     * Store `nodeName` of local identifier as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {string} nodeName\n     * @param {number} nodeIdentifier\n     */\n    public storeLocalName (nodeName: string, nodeIdentifier: number): void {\n        if (this.isReservedName(nodeName)) {\n            return;\n        }\n\n        const identifierName: string = this.identifierNamesGenerator.generate();\n\n        this.namesMap.set(`${nodeName}-${String(nodeIdentifier)}`, identifierName);\n    }\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    private isReservedName (name: string): boolean {\n        return this.options.reservedNames\n            .some((reservedName: string) => {\n                return new RegExp(reservedName, 'g').exec(name) !== null;\n            });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { Nodes } from '../../../../node/Nodes';\n\n@injectable()\nexport class BooleanLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getTrueUnaryExpressionNode (): ESTree.UnaryExpression {\n        return Nodes.getUnaryExpressionNode(\n            '!',\n            BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode()\n        );\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getFalseUnaryExpressionNode (): ESTree.UnaryExpression {\n        return Nodes.getUnaryExpressionNode(\n            '!',\n            Nodes.getArrayExpressionNode()\n        );\n    }\n\n    /**\n     * @param {boolean} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: boolean): ESTree.Node {\n        return nodeValue\n            ? BooleanLiteralObfuscatingReplacer.getTrueUnaryExpressionNode()\n            : BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     try {} catch (e) { console.log(e); };\n *\n * on:\n *     try {} catch (_0x12d45f) { console.log(_0x12d45f); };\n *\n */\n@injectable()\nexport class CatchClauseTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isCatchClauseNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (catchClauseNode: ESTree.CatchClause, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n\n        this.storeCatchClauseParam(catchClauseNode, nodeIdentifier);\n        this.replaceCatchClauseParam(catchClauseNode, nodeIdentifier);\n\n        return catchClauseNode;\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {number} nodeIdentifier\n     */\n    private storeCatchClauseParam (catchClauseNode: ESTree.CatchClause, nodeIdentifier: number): void {\n        if (NodeGuards.isIdentifierNode(catchClauseNode.param)) {\n            this.identifierObfuscatingReplacer.storeLocalName(catchClauseNode.param.name, nodeIdentifier);\n        }\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceCatchClauseParam (catchClauseNode: ESTree.CatchClause, nodeIdentifier: number): void {\n        estraverse.replace(catchClauseNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, nodeIdentifier);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        node.obfuscatedNode = true;\n                    }\n                }\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/obfuscating-transformers/CatchClauseTransformer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     class Foo { //... };\n *     new Foo();\n *\n * on:\n *     class _0x12d45f { //... };\n *     new _0x12d45f();\n */\n@injectable()\nexport class ClassDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: Map <ESTree.Node, ESTree.Identifier[]> = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isClassDeclarationNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (classDeclarationNode: ESTree.ClassDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n        const blockScopeNode: TNodeWithBlockScope = NodeUtils.getBlockScopesOfNode(classDeclarationNode)[0];\n        const isGlobalDeclaration: boolean = blockScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return classDeclarationNode;\n        }\n\n        this.storeClassName(classDeclarationNode, isGlobalDeclaration, nodeIdentifier);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(blockScopeNode)) {\n            this.replaceScopeCachedIdentifiers(blockScopeNode, nodeIdentifier);\n        } else {\n            this.replaceScopeIdentifiers(blockScopeNode, nodeIdentifier);\n        }\n\n        return classDeclarationNode;\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {boolean} isGlobalDeclaration\n     * @param {number} nodeIdentifier\n     */\n    private storeClassName (\n        classDeclarationNode: ESTree.ClassDeclaration,\n        isGlobalDeclaration: boolean,\n        nodeIdentifier: number\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(classDeclarationNode.id.name, nodeIdentifier);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(classDeclarationNode.id.name, nodeIdentifier);\n        }\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceScopeCachedIdentifiers (blockScopeNode: TNodeWithBlockScope, nodeIdentifier: number): void {\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] = <ESTree.Identifier[]>this.replaceableIdentifiers.get(blockScopeNode);\n\n        cachedReplaceableIdentifiers.forEach((replaceableIdentifier: ESTree.Identifier) => {\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, nodeIdentifier);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n        });\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceScopeIdentifiers (blockScopeNode: TNodeWithBlockScope, nodeIdentifier: number): void {\n        const storedReplaceableIdentifiers: ESTree.Identifier[] = [];\n\n        estraverse.replace(blockScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, nodeIdentifier);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                    } else {\n                        storedReplaceableIdentifiers.push(node);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(blockScopeNode, storedReplaceableIdentifiers);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/obfuscating-transformers/ClassDeclarationTransformer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     function foo () { //... };\n *     foo();\n *\n * on:\n *     function _0x12d45f () { //... };\n *     _0x12d45f();\n */\n@injectable()\nexport class FunctionDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isFunctionDeclarationNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (functionDeclarationNode: ESTree.FunctionDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n        const blockScopeNode: TNodeWithBlockScope = NodeUtils.getBlockScopesOfNode(functionDeclarationNode)[0];\n        const isGlobalDeclaration: boolean = blockScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return functionDeclarationNode;\n        }\n\n        this.storeFunctionName(functionDeclarationNode, isGlobalDeclaration, nodeIdentifier);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(blockScopeNode)) {\n            this.replaceScopeCachedIdentifiers(functionDeclarationNode, blockScopeNode, nodeIdentifier);\n        } else {\n            this.replaceScopeIdentifiers(blockScopeNode, nodeIdentifier);\n        }\n\n        return functionDeclarationNode;\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {boolean} isGlobalDeclaration\n     * @param {number} nodeIdentifier\n     */\n    private storeFunctionName (\n        functionDeclarationNode: ESTree.FunctionDeclaration,\n        isGlobalDeclaration: boolean,\n        nodeIdentifier: number\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(functionDeclarationNode.id.name, nodeIdentifier);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(functionDeclarationNode.id.name, nodeIdentifier);\n        }\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceScopeCachedIdentifiers (\n        functionDeclarationNode: ESTree.FunctionDeclaration,\n        blockScopeNode: TNodeWithBlockScope,\n        nodeIdentifier: number\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames | undefined = this.replaceableIdentifiers.get(blockScopeNode);\n\n        if (!cachedReplaceableIdentifiersNamesMap) {\n            return;\n        }\n\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined = cachedReplaceableIdentifiersNamesMap\n            .get(functionDeclarationNode.id.name);\n\n        if (!cachedReplaceableIdentifiers) {\n            return;\n        }\n\n        const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n        for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n            const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, nodeIdentifier);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n        }\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceScopeIdentifiers (blockScopeNode: TNodeWithBlockScope, nodeIdentifier: number): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(blockScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, nodeIdentifier);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] = storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(blockScopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/obfuscating-transformers/FunctionDeclarationTransformer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     function foo (argument1) { return argument1; };\n *\n * on:\n *     function foo (_0x12d45f) { return _0x12d45f; };\n *\n */\n@injectable()\nexport class FunctionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode && (\n                                NodeGuards.isFunctionDeclarationNode(node) ||\n                                NodeGuards.isFunctionExpressionNode(node) ||\n                                NodeGuards.isArrowFunctionExpressionNode(node)\n                            )\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n\n        this.storeFunctionParams(functionNode, nodeIdentifier);\n        this.replaceFunctionParams(functionNode, nodeIdentifier);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {number} nodeIdentifier\n     */\n    private storeFunctionParams (functionNode: ESTree.Function, nodeIdentifier: number): void {\n        functionNode.params\n            .forEach((paramsNode: ESTree.Node) => {\n                if (NodeGuards.isObjectPatternNode(paramsNode)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                estraverse.traverse(paramsNode, {\n                    enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                        if (NodeGuards.isAssignmentPatternNode(node) && NodeGuards.isIdentifierNode(node.left)) {\n                            this.identifierObfuscatingReplacer.storeLocalName(node.left.name, nodeIdentifier);\n\n                            return estraverse.VisitorOption.Skip;\n                        }\n\n                        if (NodeGuards.isIdentifierNode(node)) {\n                            this.identifierObfuscatingReplacer.storeLocalName(node.name, nodeIdentifier);\n                        }\n                    }\n                });\n            });\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @param {Set<string>} ignoredIdentifierNamesSet\n     */\n    private addIdentifiersToIgnoredIdentifierNamesSet (\n        properties: ESTree.Property[],\n        ignoredIdentifierNamesSet: Set<string>\n    ): void {\n        properties.forEach((property: ESTree.Property) => {\n            if (!NodeGuards.isIdentifierNode(property.key)) {\n                return;\n            }\n\n            ignoredIdentifierNamesSet.add(property.key.name);\n        });\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceFunctionParams (functionNode: ESTree.Function, nodeIdentifier: number): void {\n        const ignoredIdentifierNamesSet: Set<string> = new Set();\n\n        const replaceVisitor: estraverse.Visitor = {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (NodeGuards.isObjectPatternNode(node)) {\n                    this.addIdentifiersToIgnoredIdentifierNamesSet(node.properties, ignoredIdentifierNamesSet);\n                }\n\n                if (\n                    parentNode &&\n                    NodeGuards.isReplaceableIdentifierNode(node, parentNode) &&\n                    !ignoredIdentifierNamesSet.has(node.name)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer.replace(node.name, nodeIdentifier);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        node.obfuscatedNode = true;\n                    }\n                }\n            }\n        };\n\n        functionNode.params.forEach((paramsNode: ESTree.Node) => estraverse.replace(paramsNode, replaceVisitor));\n\n        estraverse.replace(functionNode.body, replaceVisitor);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/obfuscating-transformers/FunctionTransformer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     label: {\n *          for (var i = 0; i < 1000; i++) {\n *              break label;\n *          }\n *     }\n *\n * on:\n *     _0x12d45f: {\n *          for (var i = 0; i < 1000; i++) {\n *              break _0x12d45f;\n *          }\n *     }\n *\n */\n@injectable()\nexport class LabeledStatementTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLabeledStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (labeledStatementNode: ESTree.LabeledStatement, parentNode: ESTree.Node): ESTree.Node {\n        const nodeIdentifier: number = this.nodeIdentifier++;\n\n        this.storeLabeledStatementName(labeledStatementNode, nodeIdentifier);\n        this.replaceLabeledStatementName(labeledStatementNode, nodeIdentifier);\n\n        return labeledStatementNode;\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {number} nodeIdentifier\n     */\n    private storeLabeledStatementName (labeledStatementNode: ESTree.LabeledStatement, nodeIdentifier: number): void {\n        this.identifierObfuscatingReplacer.storeLocalName(labeledStatementNode.label.name, nodeIdentifier);\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceLabeledStatementName (labeledStatementNode: ESTree.LabeledStatement, nodeIdentifier: number): void {\n        estraverse.replace(labeledStatementNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isLabelIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, nodeIdentifier);\n\n                    node.name = newIdentifier.name;\n                }\n            }\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/obfuscating-transformers/LabeledStatementTransformer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TLiteralObfuscatingReplacerFactory } from '../../types/container/node-transformers/TLiteralObfuscatingReplacerFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { LiteralObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class LiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TLiteralObfuscatingReplacerFactory}\n     */\n    private readonly literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory;\n\n    /**\n     * @param {TLiteralObfuscatingReplacerFactory} literalObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n            literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.literalObfuscatingReplacerFactory = literalObfuscatingReplacerFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLiteralNode(node) && !node.obfuscatedNode) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): ESTree.Node {\n        if (parentNode && NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return literalNode;\n        }\n\n        switch (typeof literalNode.value) {\n            case 'boolean':\n                return this.literalObfuscatingReplacerFactory(LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer)\n                    .replace(<boolean>literalNode.value);\n\n            case 'number':\n                return this.literalObfuscatingReplacerFactory(LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer)\n                    .replace(<number>literalNode.value);\n\n            case 'string':\n                return this.literalObfuscatingReplacerFactory(LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer)\n                    .replace(<string>literalNode.value);\n\n            default:\n                return literalNode;\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/obfuscating-transformers/LiteralTransformer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { Nodes } from '../../../../node/Nodes';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class NumberLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly numberLiteralCache: Map <number, string> = new Map();\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param {number} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: number): ESTree.Node {\n        let rawValue: string;\n\n        if (this.numberLiteralCache.has(nodeValue)) {\n            rawValue = <string>this.numberLiteralCache.get(nodeValue);\n        } else {\n            if (!Utils.isCeilNumber(nodeValue)) {\n                rawValue = String(nodeValue);\n            } else {\n                rawValue = `${Utils.hexadecimalPrefix}${Utils.decToHex(nodeValue)}`;\n            }\n\n            this.numberLiteralCache.set(nodeValue, rawValue);\n        }\n\n        return Nodes.getLiteralNode(nodeValue, rawValue);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     var object = { PSEUDO: 1 };\n *\n * on:\n *     var object = { 'PSEUDO': 1 };\n */\n@injectable()\nexport class ObjectExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {Identifier} node\n     * @returns {Literal}\n     */\n    private static transformIdentifierPropertyKey (node: ESTree.Identifier): ESTree.Literal {\n        return {\n            type: NodeType.Literal,\n            value: node.name,\n            raw: `'${node.name}'`\n        };\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isObjectExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        objectExpressionNode.properties\n            .forEach((property: ESTree.Property) => {\n                if (property.computed) {\n                    return;\n                }\n\n                if (property.shorthand) {\n                    property.shorthand = false;\n                }\n\n                if (NodeGuards.isIdentifierNode(property.key)) {\n                    property.key = ObjectExpressionTransformer.transformIdentifierPropertyKey(property.key);\n                }\n            });\n\n        return objectExpressionNode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/obfuscating-transformers/ObjectExpressionTransformer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { ICryptUtils } from '../../../../interfaces/utils/ICryptUtils';\nimport { IEncodedValue } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/IEncodedValue';\nimport { IEscapeSequenceEncoder } from '../../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../../interfaces/utils/IRandomGenerator';\nimport { IStorage } from '../../../../interfaces/storages/IStorage';\nimport { IStringArrayIndexData } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/IStringArrayIndexData';\n\nimport { StringArrayEncoding } from '../../../../enums/StringArrayEncoding';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { Nodes } from '../../../../node/Nodes';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class StringLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly minimumLengthForStringArray: number = 3;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeyLength: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeysCount: number = 50;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {Map<string, ESTree.Node>}\n     */\n    private readonly nodesCache: Map <string, ESTree.Node> = new Map();\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string[]}\n     */\n    private readonly rc4Keys: string[];\n\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringLiteralHexadecimalIndexCache: Map <string, string> = new Map();\n\n    /**\n     * @type {IStorage<string>}\n     */\n    private readonly stringArrayStorage: IStorage<string>;\n\n    /**\n     * @param {IStorage<string>} stringArrayStorage\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: IStorage<string>,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(\n            options\n        );\n\n        this.stringArrayStorage = stringArrayStorage;\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n        this.randomGenerator = randomGenerator;\n        this.cryptUtils = cryptUtils;\n\n        this.rc4Keys = this.randomGenerator.getRandomGenerator()\n            .n(\n                () => this.randomGenerator.getRandomGenerator().string({\n                    length: StringLiteralObfuscatingReplacer.rc4KeyLength\n                }),\n                StringLiteralObfuscatingReplacer.rc4KeysCount\n            );\n    }\n\n    /**\n     * @param {string} hexadecimalIndex\n     * @returns {Literal}\n     */\n    private static getHexadecimalLiteralNode (hexadecimalIndex: string): ESTree.Literal {\n        const hexadecimalLiteralNode: ESTree.Literal = Nodes.getLiteralNode(hexadecimalIndex);\n\n        hexadecimalLiteralNode.obfuscatedNode = true;\n\n        return hexadecimalLiteralNode;\n    }\n\n    /**\n     * @param {string} literalValue\n     * @returns {Literal}\n     */\n    private static getRc4KeyLiteralNode (literalValue: string): ESTree.Literal {\n        const rc4KeyLiteralNode: ESTree.Literal = Nodes.getLiteralNode(literalValue);\n\n        rc4KeyLiteralNode.obfuscatedNode = true;\n\n        return rc4KeyLiteralNode;\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: string): ESTree.Node {\n        const useStringArray: boolean = this.canUseStringArray(nodeValue);\n        const cacheKey: string = `${nodeValue}-${String(useStringArray)}`;\n        const useCacheValue: boolean = this.nodesCache.has(cacheKey) && this.options.stringArrayEncoding !== StringArrayEncoding.Rc4;\n\n        if (useCacheValue) {\n            return <ESTree.Node>this.nodesCache.get(cacheKey);\n        }\n\n        const resultNode: ESTree.Node = useStringArray\n            ? this.replaceWithStringArrayCallNode(nodeValue)\n            : this.replaceWithLiteralNode(nodeValue);\n\n        this.nodesCache.set(cacheKey, resultNode);\n\n        return resultNode;\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @returns {boolean}\n     */\n    private canUseStringArray (nodeValue: string): boolean {\n        return (\n            this.options.stringArray &&\n            nodeValue.length >= StringLiteralObfuscatingReplacer.minimumLengthForStringArray &&\n            this.randomGenerator.getMathRandom() <= this.options.stringArrayThreshold\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} stringArrayStorageLength\n     * @returns {IStringArrayIndexData}\n     */\n    private getStringArrayHexadecimalIndex (value: string, stringArrayStorageLength: number): IStringArrayIndexData {\n        if (this.stringLiteralHexadecimalIndexCache.has(value)) {\n            return {\n                fromCache: true,\n                index: <string>this.stringLiteralHexadecimalIndexCache.get(value)\n            };\n        }\n\n        const hexadecimalRawIndex: string = Utils.decToHex(stringArrayStorageLength);\n        const hexadecimalIndex: string = `${Utils.hexadecimalPrefix}${hexadecimalRawIndex}`;\n\n        this.stringLiteralHexadecimalIndexCache.set(value, hexadecimalIndex);\n\n        return {\n            fromCache: false,\n            index: hexadecimalIndex\n        };\n    }\n\n    /**\n     * @param {string} value\n     * @returns {IEncodedValue}\n     */\n    private getEncodedValue (value: string): IEncodedValue {\n        let encodedValue: string;\n        let key: string | null = null;\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                key = this.randomGenerator.getRandomGenerator().pickone(this.rc4Keys);\n                encodedValue = this.cryptUtils.btoa(this.cryptUtils.rc4(value, key));\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                encodedValue = this.cryptUtils.btoa(value);\n\n                break;\n\n            default:\n                encodedValue = value;\n        }\n\n        return { encodedValue, key };\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithLiteralNode (value: string): ESTree.Node {\n        return Nodes.getLiteralNode(\n            this.escapeSequenceEncoder.encode(value, this.options.unicodeEscapeSequence)\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithStringArrayCallNode (value: string): ESTree.Node {\n        const { encodedValue, key }: IEncodedValue = this.getEncodedValue(value);\n        const escapedValue: string = this.escapeSequenceEncoder.encode(encodedValue, this.options.unicodeEscapeSequence);\n\n        const stringArrayStorageLength: number = this.stringArrayStorage.getLength();\n        const stringArrayStorageCallsWrapperName: string = this.stringArrayStorage.getStorageId().split('|')[1];\n\n        const { fromCache, index }: IStringArrayIndexData = this.getStringArrayHexadecimalIndex(\n            escapedValue,\n            stringArrayStorageLength\n        );\n\n        if (!fromCache) {\n            this.stringArrayStorage.set(stringArrayStorageLength, escapedValue);\n        }\n\n        const callExpressionArgs: (ESTree.Expression | ESTree.SpreadElement)[] = [\n            StringLiteralObfuscatingReplacer.getHexadecimalLiteralNode(index)\n        ];\n\n        if (key) {\n            callExpressionArgs.push(StringLiteralObfuscatingReplacer.getRc4KeyLiteralNode(\n                this.escapeSequenceEncoder.encode(key, this.options.unicodeEscapeSequence)\n            ));\n        }\n\n        const stringArrayIdentifierNode: ESTree.Identifier = Nodes.getIdentifierNode(stringArrayStorageCallsWrapperName);\n\n        // prevent obfuscation of this identifier\n        stringArrayIdentifierNode.obfuscatedNode = true;\n\n        return Nodes.getCallExpressionNode(\n            stringArrayIdentifierNode,\n            callExpressionArgs\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     var variable = 1;\n *     variable++;\n *\n * on:\n *     var _0x12d45f = 1;\n *     _0x12d45f++;\n *\n */\n@injectable()\nexport class VariableDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {TReplaceableIdentifiers}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isVariableDeclarationNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (variableDeclarationNode: ESTree.VariableDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const blockScopeNode: TNodeWithBlockScope = NodeUtils.getBlockScopesOfNode(variableDeclarationNode)[0];\n        const isGlobalDeclaration: boolean = blockScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return variableDeclarationNode;\n        }\n\n        const nodeIdentifier: number = this.nodeIdentifier++;\n        const scopeNode: ESTree.Node = variableDeclarationNode.kind === 'var'\n            ? blockScopeNode\n            : parentNode;\n\n        this.storeVariableNames(variableDeclarationNode, isGlobalDeclaration, nodeIdentifier);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(scopeNode)) {\n            this.replaceScopeCachedIdentifiers(variableDeclarationNode, scopeNode, nodeIdentifier);\n        } else {\n            this.replaceScopeIdentifiers(scopeNode, nodeIdentifier);\n        }\n\n        return variableDeclarationNode;\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {boolean} isGlobalDeclaration\n     * @param {number} nodeIdentifier\n     */\n    private storeVariableNames (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        isGlobalDeclaration: boolean,\n        nodeIdentifier: number\n    ): void {\n        this.traverseDeclarationIdentifiers(variableDeclarationNode, (identifierNode: ESTree.Identifier) => {\n            if (isGlobalDeclaration) {\n                this.identifierObfuscatingReplacer.storeGlobalName(identifierNode.name, nodeIdentifier);\n            } else {\n                this.identifierObfuscatingReplacer.storeLocalName(identifierNode.name, nodeIdentifier);\n            }\n        });\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {Node} scopeNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceScopeCachedIdentifiers (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        scopeNode: ESTree.Node,\n        nodeIdentifier: number\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames | undefined = this.replaceableIdentifiers.get(scopeNode);\n\n        if (!cachedReplaceableIdentifiersNamesMap) {\n            return;\n        }\n\n        const identifierNames: string[] = [];\n\n        this.traverseDeclarationIdentifiers(variableDeclarationNode, (identifierNode: ESTree.Identifier) => {\n            identifierNames.push(identifierNode.name);\n        });\n\n        identifierNames.forEach((identifierName: string) => {\n            const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined = cachedReplaceableIdentifiersNamesMap.get(identifierName);\n\n            if (!cachedReplaceableIdentifiers) {\n                return;\n            }\n\n            const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n            for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n                const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n\n                if (identifierName !== replaceableIdentifier.name) {\n                    continue;\n                }\n\n                const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                    .replace(replaceableIdentifier.name, nodeIdentifier);\n\n                replaceableIdentifier.name = newReplaceableIdentifier.name;\n            }\n        });\n    }\n\n    /**\n     * @param {NodeGuards} blockScopeNode\n     * @param {number} nodeIdentifier\n     */\n    private replaceScopeIdentifiers (blockScopeNode: ESTree.Node, nodeIdentifier: number): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(blockScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && !node.obfuscatedNode && NodeGuards.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer.replace(node.name, nodeIdentifier);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] = storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(blockScopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {(identifier: Identifier) => void} callback\n     */\n    private traverseDeclarationIdentifiers (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        callback: (identifier: ESTree.Identifier) => void\n    ): void {\n        variableDeclarationNode.declarations\n            .forEach((declarationNode: ESTree.VariableDeclarator) => {\n                if (NodeGuards.isObjectPatternNode(declarationNode.id)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                estraverse.traverse(declarationNode.id, {\n                    enter: (node: ESTree.Node) => {\n                        if (NodeGuards.isIdentifierNode(node)) {\n                            callback(node);\n                        }\n                    }\n                });\n            });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/obfuscating-transformers/VariableDeclarationTransformer.ts","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../../../interfaces/options/IOptionsNormalizer';\n\nimport { Options } from '../../../options/Options';\nimport { OptionsNormalizer } from '../../../options/OptionsNormalizer';\n\nexport const optionsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    bind<IOptions>(ServiceIdentifiers.IOptions)\n        .to(Options)\n        .inSingletonScope();\n\n    bind<IOptionsNormalizer>(ServiceIdentifiers.IOptionsNormalizer)\n        .to(OptionsNormalizer)\n        .inSingletonScope();\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/container/modules/options/OptionsModule.ts","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport {\n    ArrayUnique,\n    IsArray,\n    IsBoolean,\n    IsIn,\n    IsNumber,\n    IsString,\n    IsUrl,\n    Max,\n    Min,\n    ValidateIf,\n    validateSync,\n    ValidationError,\n    ValidatorOptions\n} from 'class-validator';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\nimport { TStringArrayEncoding } from '../types/options/TStringArrayEncoding';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { IdentifierNamesGenerator } from '../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\nimport { StringArrayEncoding } from '../enums/StringArrayEncoding';\n\nimport { DEFAULT_PRESET } from './presets/Default';\n\nimport { ValidationErrorsFormatter } from './ValidationErrorsFormatter';\n\n@injectable()\nexport class Options implements IOptions {\n    /**\n     * @type {ValidatorOptions}\n     */\n    private static readonly validatorOptions: ValidatorOptions = {\n        validationError: {\n            target: false\n        }\n    };\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly compact!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly controlFlowFlattening!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly controlFlowFlatteningThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly deadCodeInjection!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly deadCodeInjectionThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtection!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtectionInterval!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly disableConsoleOutput!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly domainLock!: string[];\n\n    /**\n     * @type {IdentifierNamesGenerator}\n     */\n    @IsIn([\n        IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n        IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n    ])\n    public readonly identifierNamesGenerator!: IdentifierNamesGenerator;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly identifiersPrefix!: string;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly log!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly renameGlobals!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly reservedNames!: string[];\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly rotateStringArray!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly seed!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly selfDefending!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly sourceMap!: boolean;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    @ValidateIf((options: IOptions) => Boolean(options.sourceMapBaseUrl))\n    @IsUrl({\n        require_protocol: true,\n        require_tld: false,\n        require_valid_protocol: true\n    })\n    public readonly sourceMapBaseUrl!: string;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly sourceMapFileName!: string;\n\n    /**\n     * @type {SourceMapMode}\n     */\n    @IsIn([SourceMapMode.Inline, SourceMapMode.Separate])\n    public readonly sourceMapMode!: SourceMapMode;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly stringArray!: boolean;\n\n    /**\n     * @type {TStringArrayEncoding}\n     */\n    @IsIn([true, false, StringArrayEncoding.Base64, StringArrayEncoding.Rc4])\n    public readonly stringArrayEncoding!: TStringArrayEncoding;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly stringArrayThreshold!: number;\n\n    /**\n     * @type {ObfuscationTarget}\n     */\n    @IsIn([ObfuscationTarget.Browser, ObfuscationTarget.Extension, ObfuscationTarget.Node])\n    public readonly target!: ObfuscationTarget;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly transformObjectKeys!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly unicodeEscapeSequence!: boolean;\n\n    /**\n     * @param {TInputOptions} inputOptions\n     * @param {IOptionsNormalizer} optionsNormalizer\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TInputOptions) inputOptions: TInputOptions,\n        @inject(ServiceIdentifiers.IOptionsNormalizer) optionsNormalizer: IOptionsNormalizer\n    ) {\n        Object.assign(this, DEFAULT_PRESET, inputOptions);\n\n        const errors: ValidationError[] = validateSync(this, Options.validatorOptions);\n\n        if (errors.length) {\n            throw new ReferenceError(`Validation failed. errors:\\n${ValidationErrorsFormatter.format(errors)}`);\n        }\n\n        Object.assign(this, optionsNormalizer.normalize(this));\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/Options.ts","module.exports = require(\"class-validator\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"class-validator\"\n// module id = 137\n// module chunks = 0","import { ValidationError } from 'class-validator';\n\nexport class ValidationErrorsFormatter {\n    /**\n     * @param {ValidationError[]} validationErrors\n     * @returns {string}\n     */\n    public static format (validationErrors: ValidationError[]): string {\n        const errorsArray: string[] = [];\n\n        for (const error of validationErrors) {\n            errorsArray.push(ValidationErrorsFormatter.formatError(error));\n        }\n\n        return errorsArray.join('\\n');\n    }\n\n    /**\n     * @param {ValidationError} validationError\n     * @returns {string}\n     */\n    private static formatError (validationError: ValidationError): string {\n        const constraints: {[type: string]: string} = validationError.constraints;\n\n        let errorString: string = `\\`${validationError.property}\\` errors:\\n`;\n\n        for (const constraint in constraints) {\n            if (!constraints.hasOwnProperty(constraint)) {\n                continue;\n            }\n\n            errorString += `    - ${constraints[constraint]}\\n`;\n        }\n\n        return errorString;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/ValidationErrorsFormatter.ts","import { injectable } from 'inversify';\n\nimport { TOptionsNormalizerRule } from '../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { ControlFlowFlatteningThresholdRule } from './normalizer-rules/ControlFlowFlatteningThresholdRule';\nimport { DeadCodeInjectionRule } from './normalizer-rules/DeadCodeInjectionRule';\nimport { DeadCodeInjectionThresholdRule } from './normalizer-rules/DeadCodeInjectionThresholdRule';\nimport { DomainLockRule } from './normalizer-rules/DomainLockRule';\nimport { SelfDefendingRule } from './normalizer-rules/SelfDefendingRule';\nimport { SourceMapBaseUrlRule } from './normalizer-rules/SourceMapBaseUrlRule';\nimport { SourceMapFileNameRule } from './normalizer-rules/SourceMapFileNameRule';\nimport { StringArrayRule } from './normalizer-rules/StringArrayRule';\nimport { StringArrayEncodingRule } from './normalizer-rules/StringArrayEncodingRule';\nimport { StringArrayThresholdRule } from './normalizer-rules/StringArrayThresholdRule';\n\n@injectable()\nexport class OptionsNormalizer implements IOptionsNormalizer {\n    /**\n     * @type {TOptionsNormalizerRule[]}\n     */\n    private static readonly normalizerRules: TOptionsNormalizerRule[] = [\n        ControlFlowFlatteningThresholdRule,\n        DeadCodeInjectionRule,\n        DeadCodeInjectionThresholdRule,\n        DomainLockRule,\n        SelfDefendingRule,\n        SourceMapBaseUrlRule,\n        SourceMapFileNameRule,\n        StringArrayRule,\n        StringArrayEncodingRule,\n        StringArrayThresholdRule,\n    ];\n\n    /**\n     * @param {IOptions} options\n     * @returns {IOptions}\n     */\n    public normalize (options: IOptions): IOptions {\n        let normalizedOptions: IOptions = {\n            ...options\n        };\n\n        for (const normalizerRule of OptionsNormalizer.normalizerRules) {\n            normalizedOptions = normalizerRule(normalizedOptions);\n        }\n\n        return normalizedOptions;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/OptionsNormalizer.ts","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const ControlFlowFlatteningThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.controlFlowFlatteningThreshold === 0) {\n        options = {\n            ...options,\n            controlFlowFlattening: false,\n            controlFlowFlatteningThreshold: 0\n        };\n    }\n\n    return options;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/normalizer-rules/ControlFlowFlatteningThresholdRule.ts","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { DEFAULT_PRESET } from '../presets/Default';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjection) {\n        options = {\n            ...options,\n            deadCodeInjection: true,\n            stringArray: true\n        };\n\n        if (!options.stringArrayThreshold) {\n            options = {\n                ...options,\n                stringArray: true,\n                stringArrayThreshold: <number>DEFAULT_PRESET.stringArrayThreshold\n            };\n        }\n    }\n\n    return options;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/normalizer-rules/DeadCodeInjectionRule.ts","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjectionThreshold === 0) {\n        options = {\n            ...options,\n            deadCodeInjection: false,\n            deadCodeInjectionThreshold: 0\n        };\n    }\n\n    return options;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/normalizer-rules/DeadCodeInjectionThresholdRule.ts","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { Utils } from '../../utils/Utils';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DomainLockRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.domainLock.length) {\n        const normalizedDomains: string[] = [];\n\n        for (const domain of options.domainLock) {\n            normalizedDomains.push(Utils.extractDomainFromUrl(domain));\n        }\n\n        options = {\n            ...options,\n            domainLock: normalizedDomains\n        };\n    }\n\n    return options;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/normalizer-rules/DomainLockRule.ts","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SelfDefendingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.selfDefending) {\n        options = {\n            ...options,\n            compact: true,\n            selfDefending: true\n        };\n    }\n\n    return options;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/normalizer-rules/SelfDefendingRule.ts","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapBaseUrlRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    const { sourceMapBaseUrl }: { sourceMapBaseUrl: string } = options;\n\n    if (!options.sourceMapFileName) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: ''\n        };\n\n        return options;\n    }\n\n    if (sourceMapBaseUrl && !sourceMapBaseUrl.endsWith('/')) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: `${sourceMapBaseUrl}/`\n        };\n    }\n\n    return options;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/normalizer-rules/SourceMapBaseUrlRule.ts","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapFileNameRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    let { sourceMapFileName }: { sourceMapFileName: string } = options;\n\n    if (sourceMapFileName) {\n        sourceMapFileName = sourceMapFileName\n            .replace(/^\\/+/, '')\n            .split('.')[0];\n\n        options = {\n            ...options,\n            sourceMapFileName: `${sourceMapFileName}.js.map`\n        };\n    }\n\n    return options;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/normalizer-rules/SourceMapFileNameRule.ts","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (!options.stringArray) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/normalizer-rules/StringArrayRule.ts","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayEncodingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayEncoding === true) {\n        options = {\n            ...options,\n            stringArrayEncoding: StringArrayEncoding.Base64\n        };\n    }\n\n    return options;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/normalizer-rules/StringArrayEncodingRule.ts","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayThreshold === 0) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/options/normalizer-rules/StringArrayThresholdRule.ts","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\nimport { ObfuscatingGuard } from '../../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\n\nimport { BlackListObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard';\nimport { CommentsTransformer } from '../../../node-transformers/preparing-transformers/CommentsTransformer';\nimport { ConditionalCommentObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard';\nimport { CustomNodesTransformer } from '../../../node-transformers/preparing-transformers/CustomNodesTransformer';\nimport { EvalCallExpressionTransformer } from '../../../node-transformers/preparing-transformers/EvaCallExpressionTransformer';\nimport { ObfuscatingGuardsTransformer } from '../../../node-transformers/preparing-transformers/ObfuscatingGuardsTransformer';\nimport { ParentificationTransformer } from '../../../node-transformers/preparing-transformers/ParentificationTransformer';\n\nexport const preparingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // preparing transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CommentsTransformer)\n        .whenTargetNamed(NodeTransformer.CommentsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CustomNodesTransformer)\n        .whenTargetNamed(NodeTransformer.CustomNodesTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(EvalCallExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.EvalCallExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObfuscatingGuardsTransformer)\n        .whenTargetNamed(NodeTransformer.ObfuscatingGuardsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ParentificationTransformer)\n        .whenTargetNamed(NodeTransformer.ParentificationTransformer);\n\n    // obfuscating guards\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(BlackListObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.BlackListNodeGuard);\n\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(ConditionalCommentObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.ConditionalCommentNodeGuard);\n\n    // obfuscating guards factory\n    bind<IObfuscatingGuard>(ServiceIdentifiers.Factory__INodeGuard)\n        .toFactory<IObfuscatingGuard>(InversifyContainerFacade\n            .getCacheFactory<ObfuscatingGuard, IObfuscatingGuard>(\n                ServiceIdentifiers.INodeGuard\n            ));\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/container/modules/node-transformers/PreparingTransformersModule.ts","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeGuard } from '../../../types/node/TNodeGuard';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class BlackListObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {((node: Node) => boolean)[]}\n     */\n    private static readonly blackListGuards: TNodeGuard[] = [\n        NodeGuards.isUseStrictOperator\n    ];\n\n    /**\n     * @type {number}\n     */\n    private readonly blackListGuardsLength: number;\n\n    constructor () {\n        this.blackListGuardsLength = BlackListObfuscatingGuard.blackListGuards.length;\n    }\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        for (let i: number = 0; i < this.blackListGuardsLength; i++) {\n            if (BlackListObfuscatingGuard.blackListGuards[i](node)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class CommentsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly preservedWords: string[] = ['@license', '@preserve'];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isNodeWithComments(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Removes all comments from node except comments that contain\n     * `@license`, `@preserve` or `javascript-obfuscator` words\n     *\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node): ESTree.Node {\n        if (node.leadingComments) {\n            node.leadingComments = this.transformComments(node.leadingComments);\n        }\n\n        if (node.trailingComments) {\n            node.trailingComments = this.transformComments(node.trailingComments);\n        }\n\n        return node;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {Comment[]}\n     */\n    private transformComments (comments: ESTree.Comment[]): ESTree.Comment[] {\n        return comments.filter((comment: ESTree.Comment) =>\n            CommentsTransformer.preservedWords\n                .some((availableWord: string) => comment.value.includes(availableWord))\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/preparing-transformers/CommentsTransformer.ts","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class ConditionalCommentObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationEnableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *enable');\n\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationDisableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *disable');\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForCurrentNode: boolean = true;\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForNextNode: boolean | null = null;\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        if (this.obfuscationAllowedForNextNode) {\n            this.obfuscationAllowedForCurrentNode = this.obfuscationAllowedForNextNode;\n            this.obfuscationAllowedForNextNode = null;\n        }\n\n        if (!NodeGuards.isNodeWithComments(node)) {\n            return this.obfuscationAllowedForCurrentNode;\n        }\n\n        const leadingComments: ESTree.Comment[] | undefined = node.leadingComments;\n        const trailingComments: ESTree.Comment[] | undefined = node.trailingComments;\n\n        if (leadingComments) {\n            this.obfuscationAllowedForCurrentNode = this.checkComments(leadingComments);\n        }\n\n        if (trailingComments) {\n            this.obfuscationAllowedForNextNode = this.checkComments(trailingComments);\n        }\n\n        return this.obfuscationAllowedForCurrentNode;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {boolean}\n     */\n    private checkComments (comments: ESTree.Comment[]): boolean {\n        const commentsLength: number = comments.length;\n\n        let obfuscationAllowed: boolean = this.obfuscationAllowedForCurrentNode;\n\n        for (let i: number = 0; i < commentsLength; i++) {\n            const comment: ESTree.Comment = comments[i];\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationEnableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = true;\n\n                continue;\n            }\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationDisableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = false;\n            }\n        }\n\n        return obfuscationAllowed;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IObfuscationEventEmitter } from '../../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceAnalyzer } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\nimport { IStorage } from '../../interfaces/storages/IStorage';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Analyzing AST-tree and appending custom nodes\n */\n@injectable()\nexport class CustomNodesTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IStorage<ICustomNodeGroup>}\n     */\n    private readonly customNodeGroupStorage: IStorage<ICustomNodeGroup>;\n\n    /**\n     * @type {IObfuscationEventEmitter}\n     */\n    private readonly obfuscationEventEmitter: IObfuscationEventEmitter;\n\n    /**\n     * @type {IStackTraceAnalyzer}\n     */\n    private readonly stackTraceAnalyzer: IStackTraceAnalyzer;\n\n    /**\n     * @type {IStackTraceData[]}\n     */\n    private stackTraceData: IStackTraceData[] = [];\n\n    /**\n     * @param {IStackTraceAnalyzer} stackTraceAnalyzer\n     * @param {IObfuscationEventEmitter} obfuscationEventEmitter\n     * @param {IStorage<ICustomNodeGroup>} customNodeGroupStorage\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IStackTraceAnalyzer) stackTraceAnalyzer: IStackTraceAnalyzer,\n        @inject(ServiceIdentifiers.IObfuscationEventEmitter) obfuscationEventEmitter: IObfuscationEventEmitter,\n        @inject(ServiceIdentifiers.TCustomNodeGroupStorage) customNodeGroupStorage: IStorage<ICustomNodeGroup>,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.stackTraceAnalyzer = stackTraceAnalyzer;\n        this.obfuscationEventEmitter = obfuscationEventEmitter;\n        this.customNodeGroupStorage = customNodeGroupStorage;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n                            this.appendCustomNodesBeforeObfuscation(node, parentNode);\n\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.appendCustomNodesAfterObfuscation(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    public analyzeNode (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.stackTraceData = this.stackTraceAnalyzer.analyze(node);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Program, parentNode: ESTree.Node | null): ESTree.Node {\n        return node;\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesBeforeObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.customNodeGroupStorage\n            .getStorage()\n            .forEach((customNodeGroup: ICustomNodeGroup) => {\n                customNodeGroup.initialize();\n\n                this.obfuscationEventEmitter.once(\n                    customNodeGroup.getAppendEvent(),\n                    customNodeGroup.appendCustomNodes.bind(customNodeGroup)\n                );\n            });\n\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.BeforeObfuscation, node, this.stackTraceData);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesAfterObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.AfterObfuscation, node, this.stackTraceData);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/preparing-transformers/CustomNodesTransformer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\nimport jsStringEscape from 'js-string-escape';\n\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { Nodes } from '../../node/Nodes';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class EvalCallExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Set <FunctionExpression>}\n     */\n    private readonly evalRootAstHostNodeSet: Set <ESTree.FunctionExpression> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {Expression | SpreadElement} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromCallExpressionArgument (node: ESTree.Expression | ESTree.SpreadElement): string | null {\n        if (NodeGuards.isLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromLiteralNode(node);\n        }\n\n        if (NodeGuards.isTemplateLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromTemplateLiteralNode(node);\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Literal} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromLiteralNode (node: ESTree.Literal): string | null {\n        return typeof node.value === 'string' ? node.value : null;\n    }\n\n    /**\n     * @param {TemplateLiteral} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromTemplateLiteralNode (node: ESTree.TemplateLiteral): string | null {\n        const quasis: ESTree.TemplateElement[] = node.quasis;\n        const allowedQuasisLength: number = 1;\n\n        if (quasis.length !== allowedQuasisLength || node.expressions.length) {\n            return null;\n        }\n\n        return quasis[0].value.cooked;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isCallExpressionNode(node)\n                            && NodeGuards.isIdentifierNode(node.callee)\n                            && node.callee.name === 'eval'\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.evalRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isEvalRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (callExpressionNode: ESTree.CallExpression, parentNode: ESTree.Node): ESTree.Node {\n        const callExpressionFirstArgument: ESTree.Expression | ESTree.SpreadElement = callExpressionNode.arguments[0];\n\n        if (!callExpressionFirstArgument) {\n            return callExpressionNode;\n        }\n\n        const evalString: string | null = EvalCallExpressionTransformer\n            .extractEvalStringFromCallExpressionArgument(callExpressionFirstArgument);\n\n        if (!evalString) {\n            return callExpressionNode;\n        }\n\n        let ast: TStatement[];\n\n        // wrapping into try-catch to prevent parsing of incorrect `eval` string\n        try {\n            ast = NodeUtils.convertCodeToStructure(evalString);\n        } catch (e) {\n            return callExpressionNode;\n        }\n\n        /**\n         * we should wrap AST-tree into the parent function expression node (ast root host node).\n         * This function expression node will help to correctly transform AST-tree.\n         */\n        const evalRootAstHostNode: ESTree.FunctionExpression = Nodes\n            .getFunctionExpressionNode([], Nodes.getBlockStatementNode(<any>ast));\n\n        /**\n         * we should store that host node and then extract AST-tree on the `finalizing` stage\n         */\n        this.evalRootAstHostNodeSet.add(evalRootAstHostNode);\n\n        return evalRootAstHostNode;\n    }\n\n    /**\n     * @param {FunctionExpression} evalRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (evalRootAstHostNode: ESTree.FunctionExpression, parentNode: ESTree.Node): ESTree.Node {\n        const targetAst: ESTree.Statement[] = evalRootAstHostNode.body.body;\n        const obfuscatedCode: string = NodeUtils.convertStructureToCode(targetAst);\n\n        return Nodes.getCallExpressionNode(\n            Nodes.getIdentifierNode('eval'),\n            [\n                Nodes.getLiteralNode(jsStringEscape(obfuscatedCode))\n            ]\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isEvalRootAstHostNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return NodeGuards.isFunctionExpressionNode(node) && this.evalRootAstHostNodeSet.has(node);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/preparing-transformers/EvaCallExpressionTransformer.ts","module.exports = require(\"js-string-escape\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"js-string-escape\"\n// module id = 156\n// module chunks = 0","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TObfuscatingGuardFactory } from '../../types/container/node-transformers/TObfuscatingGuardFactory';\n\nimport { IObfuscatingGuard } from '../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscatingGuard } from '../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\n\n/**\n * Adds `ignoredNode` properties to each node\n */\n@injectable()\nexport class ObfuscatingGuardsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {ObfuscatingGuard[]}\n     */\n    private static readonly obfuscatingGuardsList: ObfuscatingGuard[] = [\n        ObfuscatingGuard.BlackListNodeGuard,\n        ObfuscatingGuard.ConditionalCommentNodeGuard\n    ];\n\n    /**\n     * @type {IObfuscatingGuard[]}\n     */\n    private readonly obfuscatingGuards: IObfuscatingGuard[];\n\n    /**\n     * @param {TObfuscatingGuardFactory} obfuscatingGuardFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeGuard) obfuscatingGuardFactory: TObfuscatingGuardFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.obfuscatingGuards = ObfuscatingGuardsTransformer.obfuscatingGuardsList.map(obfuscatingGuardFactory);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        const obfuscationAllowed: boolean = this.obfuscatingGuards\n            .every((nodeGuard: IObfuscatingGuard) => nodeGuard.check(node));\n\n        node.ignoredNode = !obfuscationAllowed;\n\n        return node;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/preparing-transformers/ObfuscatingGuardsTransformer.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * Adds `parentNode` properties to each node\n */\n@injectable()\nexport class ParentificationTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        return NodeUtils.parentizeNode(node, parentNode);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/preparing-transformers/ParentificationTransformer.ts","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TCustomNodeGroupStorage } from '../../../types/storages/TCustomNodeGroupStorage';\nimport { TStringArrayStorage } from '../../../types/storages/TStringArrayStorage';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowStorage } from '../../../storages/control-flow/ControlFlowStorage';\nimport { CustomNodeGroupStorage } from '../../../storages/custom-node-group/CustomNodeGroupStorage';\nimport { StringArrayStorage } from '../../../storages/string-array/StringArrayStorage';\n\nexport const storagesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // storages\n    bind<TCustomNodeGroupStorage>(ServiceIdentifiers.TCustomNodeGroupStorage)\n        .to(CustomNodeGroupStorage)\n        .inSingletonScope();\n\n    bind<TStringArrayStorage>(ServiceIdentifiers.TStringArrayStorage)\n        .to(StringArrayStorage)\n        .inSingletonScope();\n\n    bind<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage)\n        .toConstructor(ControlFlowStorage);\n\n    // controlFlowStorage factory\n    bind<TControlFlowStorage>(ServiceIdentifiers.Factory__TControlFlowStorage)\n        .toFactory<TControlFlowStorage>((context: interfaces.Context) => {\n            return () => {\n                const constructor: interfaces.Newable<TControlFlowStorage> = context.container\n                    .get<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage);\n                const randomGenerator: IRandomGenerator = context.container\n                    .get<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator);\n                const options: IOptions = context.container\n                    .get<IOptions>(ServiceIdentifiers.IOptions);\n\n                const storage: TControlFlowStorage = new constructor(randomGenerator, options);\n\n                storage.initialize();\n\n                return storage;\n            };\n        });\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/container/modules/storages/StoragesModule.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class ControlFlowStorage extends MapStorage <ICustomNode> {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/storages/control-flow/ControlFlowStorage.ts","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TCustomNodeGroupFactory } from '../../types/container/custom-nodes/TCustomNodeGroupFactory';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { CustomNodeGroup } from '../../enums/custom-nodes/CustomNodeGroup';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class CustomNodeGroupStorage extends MapStorage <ICustomNodeGroup> {\n    /**\n     * @type {CustomNodeGroup[]}\n     */\n    private static readonly customNodeGroupsList: CustomNodeGroup[] = [\n        CustomNodeGroup.ConsoleOutputCustomNodeGroup,\n        CustomNodeGroup.DebugProtectionCustomNodeGroup,\n        CustomNodeGroup.DomainLockCustomNodeGroup,\n        CustomNodeGroup.SelfDefendingCustomNodeGroup,\n        CustomNodeGroup.StringArrayCustomNodeGroup\n    ];\n\n    /**\n     * @type {TCustomNodesFactoriesFactory}\n     */\n    private readonly customNodeGroupFactory: TCustomNodeGroupFactory;\n\n    /**\n     * @param {TCustomNodeGroupFactory} customNodeGroupFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNodeGroup) customNodeGroupFactory: TCustomNodeGroupFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.customNodeGroupFactory = customNodeGroupFactory;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        CustomNodeGroupStorage.customNodeGroupsList.forEach((customNodeGroupName: CustomNodeGroup) => {\n            const customNodeGroup: ICustomNodeGroup = this.customNodeGroupFactory(\n                customNodeGroupName\n            );\n\n            if (!customNodeGroup) {\n                return;\n            }\n\n            this.storage.set(customNodeGroupName, customNodeGroup);\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/storages/custom-node-group/CustomNodeGroupStorage.ts","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { ArrayStorage } from '../ArrayStorage';\n\n@injectable()\nexport class StringArrayStorage extends ArrayStorage <string> {\n    /**\n     * @type {number}\n     */\n    private static readonly stringArrayNameLength: number = 7;\n\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.arrayUtils = arrayUtils;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        const baseStringArrayName: string = this.identifierNamesGenerator\n            .generate()\n            .slice(0, StringArrayStorage.stringArrayNameLength);\n        const baseStringArrayCallsWrapperName: string = this.identifierNamesGenerator\n            .generate()\n            .slice(0, StringArrayStorage.stringArrayNameLength);\n        const stringArrayName: string = `${this.options.identifiersPrefix}${baseStringArrayName}`;\n        const stringArrayCallsWrapperName: string = `${this.options.identifiersPrefix}${baseStringArrayCallsWrapperName}`;\n\n        this.storageId = `${stringArrayName}|${stringArrayCallsWrapperName}`;\n    }\n\n    /**\n     * @param {number} rotationValue\n     */\n    public rotateArray (rotationValue: number): void {\n        this.storage = this.arrayUtils.arrayRotate(this.storage, rotationValue);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.storage.map((value: string) => {\n            return `'${value}'`;\n        }).toString();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/storages/string-array/StringArrayStorage.ts","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IStorage } from '../interfaces/storages/IStorage';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class ArrayStorage <T> implements IStorage <T> {\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {T[]}\n     */\n    @initializable()\n    protected storage!: T[];\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {number}\n     */\n    private storageLength: number = 0;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = [];\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {number} key\n     * @returns {T}\n     */\n    public get (key: number): T {\n        const value: T | undefined = this.storage[key];\n\n        if (!value) {\n            throw new Error(`No value found in array storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {T} value\n     * @returns {number}\n     */\n    public getKeyOf (value: T): number | null {\n        const key: number = this.storage.indexOf(value);\n\n        return key >= 0 ? key : null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storageLength;\n    }\n\n    /**\n     * @returns {T[]}\n     */\n    public getStorage (): T[] {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = [...this.storage, ...storage.getStorage()];\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {number} key\n     * @param {T} value\n     */\n    public set (key: number, value: T): void {\n        if (key === this.storageLength) {\n            this.storage.push(value);\n        } else {\n            this.storage.splice(key, 0, value);\n        }\n\n        this.storageLength++;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/storages/ArrayStorage.ts","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../../interfaces/utils/IArrayUtils';\nimport { ICryptUtils } from '../../../interfaces/utils/ICryptUtils';\nimport { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ArrayUtils } from '../../../utils/ArrayUtils';\nimport { CryptUtils } from '../../../utils/CryptUtils';\nimport { EscapeSequenceEncoder } from '../../../utils/EscapeSequenceEncoder';\nimport { RandomGenerator } from '../../../utils/RandomGenerator';\n\nexport const utilsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // array utils\n    bind<IArrayUtils>(ServiceIdentifiers.IArrayUtils)\n        .to(ArrayUtils)\n        .inSingletonScope();\n\n    // random generator\n    bind<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator)\n        .to(RandomGenerator)\n        .inSingletonScope();\n\n    // crypt utils\n    bind<ICryptUtils>(ServiceIdentifiers.ICryptUtils)\n        .to(CryptUtils)\n        .inSingletonScope();\n\n    // escape sequence encoder\n    bind<IEscapeSequenceEncoder>(ServiceIdentifiers.IEscapeSequenceEncoder)\n        .to(EscapeSequenceEncoder)\n        .inSingletonScope();\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/container/modules/utils/UtilsModule.ts","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport class ArrayUtils implements IArrayUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    /**\n     * @param {number} length\n     * @returns {number[]}\n     */\n    public arrayRange (length: number): number[] {\n        const range: number[] = [];\n\n        for (let i: number = 0; i < length; i++) {\n            range.push(i);\n        }\n\n        return range;\n    }\n\n    /**\n     * @param {T[]} array\n     * @param {number} times\n     * @returns {T[]}\n     */\n    public arrayRotate <T> (array: T[], times: number): T[] {\n        if (!array.length) {\n            throw new ReferenceError(`Cannot rotate empty array.`);\n        }\n\n        if (times <= 0) {\n            return array;\n        }\n\n        const newArray: T[] = array;\n\n        let temp: T | undefined;\n\n        while (times--) {\n            temp = newArray.pop()!;\n            newArray.unshift(temp);\n        }\n\n        return newArray;\n    }\n\n    /**\n     * @param {T[]} array\n     * @returns {T[]}\n     */\n    public arrayShuffle <T> (array: T[]): T[] {\n        const shuffledArray: T[] = [...array];\n\n        for (let i: number = shuffledArray.length; i; i--) {\n            const j: number = Math.floor(this.randomGenerator.getMathRandom() * i);\n\n            [shuffledArray[i - 1], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i - 1]];\n        }\n\n        return shuffledArray;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/ArrayUtils.ts","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { RandomGenerator } from './RandomGenerator';\nimport { Utils } from './Utils';\n\n@injectable()\nexport class CryptUtils implements ICryptUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    /* tslint:disable */\n    /**\n     * @param {string} string\n     * @returns {string}\n     */\n    public btoa (string: string): string {\n        const chars: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n        let output: string = '';\n\n        string = encodeURIComponent(string).replace(/%([0-9A-F]{2})/g, (match, p1) => {\n            return String.fromCharCode(parseInt(`${Utils.hexadecimalPrefix}${p1}`));\n        });\n\n        for (\n            let block: number | undefined, charCode: number, idx: number = 0, map: string = chars;\n            string.charAt(idx | 0) || (map = '=', idx % 1);\n            output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n        ) {\n            charCode = string.charCodeAt(idx += 3/4);\n\n            if (charCode > 0xFF) {\n                throw new Error(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n            }\n\n            block = <number>block << 8 | charCode;\n        }\n\n        return output;\n    }\n    /* tslint:enable */\n\n    /**\n     * @param {string} str\n     * @param {number} length\n     * @returns {[string , string]}\n     */\n    public hideString (str: string, length: number): [string, string] {\n        const escapeRegExp: (s: string) => string = (s: string) =>\n            s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n        const randomMerge: (s1: string, s2: string) => string = (s1: string, s2: string): string => {\n            let i1: number = -1;\n            let i2: number = -1;\n            let result: string = '';\n\n            while (i1 < s1.length || i2 < s2.length) {\n                if (this.randomGenerator.getMathRandom() < 0.5 && i2 < s2.length) {\n                    result += s2.charAt(++i2);\n                } else {\n                    result += s1.charAt(++i1);\n                }\n            }\n\n            return result;\n        };\n\n        const randomString: string = this.randomGenerator.getRandomGenerator().string({\n            length: length,\n            pool: RandomGenerator.randomGeneratorPool\n        });\n\n        let randomStringDiff: string = randomString.replace(\n            new RegExp(`[${escapeRegExp(str)}]`, 'g'),\n            '');\n\n        const randomStringDiffArray: string[] = randomStringDiff.split('');\n\n        this.randomGenerator.getRandomGenerator().shuffle(randomStringDiffArray);\n        randomStringDiff = randomStringDiffArray.join('');\n\n        return [randomMerge(str, randomStringDiff), randomStringDiff];\n    }\n\n    /* tslint:disable */\n    /**\n     * RC4 symmetric cipher encryption/decryption\n     * https://gist.github.com/farhadi/2185197\n     *\n     * @param {string} string\n     * @param {string} key\n     * @returns {string}\n     */\n    public rc4 (string: string, key: string): string {\n        let s: number[] = [],\n            j: number = 0,\n            x: number,\n            result: string = '';\n\n        for (var i = 0; i < 256; i++) {\n            s[i] = i;\n        }\n\n        for (i = 0; i < 256; i++) {\n            j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n        }\n\n        i = 0;\n        j = 0;\n\n        for (let y = 0; y < string.length; y++) {\n            i = (i + 1) % 256;\n            j = (j + s[i]) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n            result += String.fromCharCode(string.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n        }\n\n        return result;\n    }\n    /* tslint:enable */\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/CryptUtils.ts","module.exports = require(\"md5\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"md5\"\n// module id = 167\n// module chunks = 0","module.exports = require(\"chance\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"chance\"\n// module id = 168\n// module chunks = 0","import { injectable } from 'inversify';\n\nimport { IEscapeSequenceEncoder } from '../interfaces/utils/IEscapeSequenceEncoder';\n\n@injectable()\nexport class EscapeSequenceEncoder implements IEscapeSequenceEncoder {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringsCache: Map <string, string> = new Map();\n\n    /**\n     * @param {string} string\n     * @param {boolean} encodeAllSymbols\n     * @returns {string}\n     */\n    public encode (string: string, encodeAllSymbols: boolean): string {\n        const cacheKey: string = `${string}-${String(encodeAllSymbols)}`;\n\n        if (this.stringsCache.has(cacheKey)) {\n            return <string>this.stringsCache.get(cacheKey);\n        }\n\n        const radix: number = 16;\n        const replaceRegExp: RegExp = new RegExp('[\\\\s\\\\S]', 'g');\n        const escapeSequenceRegExp: RegExp = new RegExp('[\\'\\\"\\\\\\\\\\\\s]');\n        const regExp: RegExp = new RegExp('[\\\\x00-\\\\x7F]');\n\n        let prefix: string;\n        let template: string;\n\n        const result: string = string.replace(replaceRegExp, (character: string): string => {\n            if (!encodeAllSymbols && !escapeSequenceRegExp.exec(character)) {\n                return character;\n            }\n\n            if (regExp.exec(character)) {\n                prefix = '\\\\x';\n                template = '00';\n            } else {\n                prefix = '\\\\u';\n                template = '0000';\n            }\n\n            return `${prefix}${(template + character.charCodeAt(0).toString(radix)).slice(-template.length)}`;\n        });\n\n        this.stringsCache.set(cacheKey, result);\n\n        return result;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils/EscapeSequenceEncoder.ts","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport * as escodegen from 'escodegen-wallaby';\nimport * as ESTree from 'estree';\nimport * as packageJson from 'pjson';\n\nimport { IGeneratorOutput } from './interfaces/IGeneratorOutput';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { ILogger } from './interfaces/logger/ILogger';\nimport { IObfuscationResult } from './interfaces/IObfuscationResult';\nimport { IOptions } from './interfaces/options/IOptions';\nimport { IRandomGenerator } from './interfaces/utils/IRandomGenerator';\nimport { ISourceMapCorrector } from './interfaces/source-map/ISourceMapCorrector';\nimport { ITransformersRunner } from './interfaces/node-transformers/ITransformersRunner';\n\nimport { LoggingMessage } from './enums/logger/LoggingMessage';\nimport { NodeTransformer } from './enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from './enums/node-transformers/TransformationStage';\n\nimport { EsprimaFacade } from './EsprimaFacade';\nimport { NodeGuards } from './node/NodeGuards';\n\n@injectable()\nexport class JavaScriptObfuscator implements IJavaScriptObfuscator {\n    /**\n     * @type {GenerateOptions}\n     */\n    private static readonly escodegenParams: escodegen.GenerateOptions = {\n        comment: true,\n        verbatim: 'x-verbatim-property',\n        sourceMapWithCode: true\n    };\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersList: NodeTransformer[] = [\n        NodeTransformer.BlockStatementControlFlowTransformer,\n        NodeTransformer.ClassDeclarationTransformer,\n        NodeTransformer.CommentsTransformer,\n        NodeTransformer.CustomNodesTransformer,\n        NodeTransformer.DeadCodeInjectionTransformer,\n        NodeTransformer.EvalCallExpressionTransformer,\n        NodeTransformer.FunctionControlFlowTransformer,\n        NodeTransformer.CatchClauseTransformer,\n        NodeTransformer.FunctionDeclarationTransformer,\n        NodeTransformer.FunctionTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.LiteralTransformer,\n        NodeTransformer.MemberExpressionTransformer,\n        NodeTransformer.MethodDefinitionTransformer,\n        NodeTransformer.ObfuscatingGuardsTransformer,\n        NodeTransformer.ObjectExpressionKeysTransformer,\n        NodeTransformer.ObjectExpressionTransformer,\n        NodeTransformer.ParentificationTransformer,\n        NodeTransformer.TemplateLiteralTransformer,\n        NodeTransformer.VariableDeclarationTransformer\n    ];\n\n    /**\n     * @type {ILogger}\n     */\n    private readonly logger: ILogger;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {ISourceMapCorrector}\n     */\n    private readonly sourceMapCorrector: ISourceMapCorrector;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {ITransformersRunner} transformersRunner\n     * @param {ISourceMapCorrector} sourceMapCorrector\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ILogger} logger\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.ISourceMapCorrector) sourceMapCorrector: ISourceMapCorrector,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ILogger) logger: ILogger,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.transformersRunner = transformersRunner;\n        this.sourceMapCorrector = sourceMapCorrector;\n        this.randomGenerator = randomGenerator;\n        this.logger = logger;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {IObfuscationResult}\n     */\n    public obfuscate (sourceCode: string): IObfuscationResult {\n        const timeStart: number = Date.now();\n        this.logger.info(LoggingMessage.Version, packageJson.version);\n        this.logger.info(LoggingMessage.ObfuscationStarted);\n        this.logger.info(LoggingMessage.RandomGeneratorSeed, this.randomGenerator.getSeed());\n\n        // parse AST tree\n        const astTree: ESTree.Program = this.parseCode(sourceCode);\n\n        // obfuscate AST tree\n        const obfuscatedAstTree: ESTree.Program = this.transformAstTree(astTree);\n\n        // generate code\n        const generatorOutput: IGeneratorOutput = this.generateCode(sourceCode, obfuscatedAstTree);\n\n        const obfuscationTime: number = (Date.now() - timeStart) / 1000;\n        this.logger.success(LoggingMessage.ObfuscationCompleted, obfuscationTime);\n\n        return this.getObfuscationResult(generatorOutput);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {Program}\n     */\n    private parseCode (sourceCode: string): ESTree.Program {\n        return EsprimaFacade.parseScript(sourceCode, {\n            attachComment: true,\n            loc: this.options.sourceMap\n        });\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {Program}\n     */\n    private transformAstTree (astTree: ESTree.Program): ESTree.Program {\n        const isEmptyAstTree: boolean = NodeGuards.isProgramNode(astTree)\n            && !astTree.body.length\n            && !astTree.leadingComments;\n\n        if (isEmptyAstTree) {\n            this.logger.warn(LoggingMessage.EmptySourceCode);\n\n            return astTree;\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Preparing);\n\n        if (this.options.deadCodeInjection) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.DeadCodeInjection);\n        }\n\n        if (this.options.controlFlowFlattening) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.ControlFlowFlattening);\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Converting);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Obfuscating);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Finalizing);\n\n        return astTree;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {Program} astTree\n     * @returns {IGeneratorOutput}\n     */\n    private generateCode (sourceCode: string, astTree: ESTree.Program): IGeneratorOutput {\n        const escodegenParams: escodegen.GenerateOptions = {\n            ...JavaScriptObfuscator.escodegenParams\n        };\n\n        if (this.options.sourceMap) {\n            escodegenParams.sourceMap = 'sourceMap';\n            escodegenParams.sourceContent = sourceCode;\n        }\n\n        const generatorOutput: IGeneratorOutput = escodegen.generate(astTree, {\n            ...escodegenParams,\n            format: {\n                compact: this.options.compact\n            }\n        });\n\n        generatorOutput.map = generatorOutput.map ? generatorOutput.map.toString() : '';\n\n        return generatorOutput;\n    }\n\n    /**\n     * @param {IGeneratorOutput} generatorOutput\n     * @returns {IObfuscationResult}\n     */\n    private getObfuscationResult (generatorOutput: IGeneratorOutput): IObfuscationResult {\n        return this.sourceMapCorrector.correct(\n            generatorOutput.code,\n            generatorOutput.map\n        );\n    }\n\n    /**\n     * @param {Program} astTree\n     * @param {TransformationStage} transformationStage\n     * @returns {Program}\n     */\n    private runTransformationStage (astTree: ESTree.Program, transformationStage: TransformationStage): ESTree.Program {\n        this.logger.info(LoggingMessage.TransformationStage, transformationStage);\n\n        return this.transformersRunner.transform(\n            astTree,\n            JavaScriptObfuscator.transformersList,\n            transformationStage\n        );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/JavaScriptObfuscator.ts","export enum LoggingMessage {\n    EmptySourceCode = 'Empty source code. Obfuscation canceled...',\n    ObfuscationCompleted = 'Obfuscation completed. Total time: %s sec.',\n    ObfuscationStarted = 'Obfuscation started...',\n    RandomGeneratorSeed = 'Random generator seed: %s...',\n    TransformationStage = 'Transformation stage: %s...',\n    Version = 'Version: %s'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/logger/LoggingMessage.ts","import * as esprima from 'esprima';\nimport * as ESTree from 'estree';\n\nimport chalk, { Chalk } from 'chalk';\n\n/**\n * Facade over `esprima` to handle parsing errors and provide more detailed error messages\n */\nexport class EsprimaFacade {\n    /**\n     * @type {Chalk}\n     */\n    private static readonly colorError: Chalk = chalk.red;\n\n    /**\n     * @type {number}\n     */\n    private static readonly nearestSymbolsCount: number = 10;\n\n    /**\n     * @param {string} input\n     * @param {ParseOptions} config\n     * @returns {Program}\n     */\n    public static parseScript (input: string, config: esprima.ParseOptions): ESTree.Program {\n        let lastMeta: esprima.NodeMeta | null = null;\n\n        try {\n            return esprima.parseScript(input, config, (node: ESTree.Node, meta: any) => lastMeta = meta);\n        } catch (error) {\n            return EsprimaFacade.processParsingError(input, error.message, lastMeta);\n        }\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} errorMessage\n     * @param {\"esprima\".NodeMeta | null} meta\n     * @returns {never}\n     */\n    private static processParsingError (sourceCode: string, errorMessage: string, meta: esprima.NodeMeta | null): never {\n        if (!meta || !meta.start || !meta.end || !meta.start.column || !meta.end.column) {\n            throw new Error(errorMessage);\n        }\n\n        const lineNumberMatch: RegExpMatchArray | null = errorMessage.match(/Line *(\\d*)/);\n\n        if (!lineNumberMatch) {\n            throw new Error(errorMessage);\n        }\n\n        const lineNumber: number = parseInt(lineNumberMatch[1], 10);\n        const sourceCodeLines: string[] = sourceCode.split(/\\r?\\n/);\n        const errorLine: string | undefined = sourceCodeLines[lineNumber - 1];\n\n        if (!errorLine) {\n            throw new Error(errorMessage);\n        }\n\n        const startErrorIndex: number = Math.max(0, meta.start.column - EsprimaFacade.nearestSymbolsCount);\n        const endErrorIndex: number = Math.min(errorLine.length, meta.end.column + EsprimaFacade.nearestSymbolsCount);\n\n        const formattedPointer: string = EsprimaFacade.colorError('>');\n        const formattedCodeSlice: string = `...${\n            errorLine.substring(startErrorIndex, endErrorIndex).replace(/^\\s+/, '')\n        }...`;\n\n        throw new Error(`${errorMessage}\\n${formattedPointer} ${formattedCodeSlice}`);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/EsprimaFacade.ts","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport chalk, { Chalk } from 'chalk';\n\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IOptions } from '../interfaces/options/IOptions';\n\nimport { LoggingMessage } from '../enums/logger/LoggingMessage';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport class Logger implements ILogger, IInitializable {\n    /**\n     * @type {string}\n     */\n    private static readonly loggingPrefix: string = '[javascript-obfuscator]';\n\n    /**\n     * @type {Chalk}\n     */\n    @initializable()\n    private colorInfo!: Chalk;\n\n    /**\n     * @type {Chalk}\n     */\n    @initializable()\n    private colorSuccess!: Chalk;\n\n    /**\n     * @type {Chalk}\n     */\n    @initializable()\n    private colorWarn!: Chalk;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.colorInfo = chalk.cyan;\n        this.colorSuccess = chalk.green;\n        this.colorWarn = chalk.yellow;\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public info (loggingMessage: LoggingMessage, value?: string | number): void {\n        this.log(this.colorInfo, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public success (loggingMessage: LoggingMessage, value?: string | number): void {\n        this.log(this.colorSuccess, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public warn (loggingMessage: LoggingMessage, value?: string | number): void {\n        this.log(this.colorWarn, loggingMessage, value);\n    }\n\n    /**\n     *\n     * @param {Chalk} loggingLevelColor\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    private log (loggingLevelColor: Chalk, loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        const processedMessage: string = loggingLevelColor(`\\n${Logger.loggingPrefix} ${loggingMessage}`);\n\n        !value ? console.log(processedMessage) : console.log(processedMessage, value);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/logger/Logger.ts","import { decorate, injectable } from 'inversify';\n\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\n\nimport { EventEmitter } from 'events';\n\ndecorate(injectable(), EventEmitter);\n\n@injectable()\nexport class ObfuscationEventEmitter extends EventEmitter implements IObfuscationEventEmitter {}\n\n\n\n// WEBPACK FOOTER //\n// ./src/event-emitters/ObfuscationEventEmitter.ts","module.exports = require(\"events\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"events\"\n// module id = 175\n// module chunks = 0","import { injectable } from 'inversify';\n\nimport { IObfuscationResult } from './interfaces/IObfuscationResult';\n\nimport { initializable } from './decorators/Initializable';\n\n@injectable()\nexport class ObfuscationResult implements IObfuscationResult {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private obfuscatedCode!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private sourceMap!: string;\n\n    /**\n     * @param {string} obfuscatedCode\n     * @param {string} sourceMap\n     */\n    public initialize (obfuscatedCode: string, sourceMap: string): void {\n        this.obfuscatedCode = obfuscatedCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getObfuscatedCode (): string {\n        return this.obfuscatedCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.obfuscatedCode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ObfuscationResult.ts","import { ISourceCode } from './interfaces/ISourceCode';\n\nexport class SourceCode implements ISourceCode {\n    /**\n     * @type {string}\n     */\n    private readonly sourceCode: string;\n\n    /**\n     * @param {string} sourceCode\n     */\n    constructor (sourceCode: string) {\n        this.sourceCode = sourceCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceCode (): string {\n        return this.sourceCode;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/SourceCode.ts","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TObfuscationResultFactory } from '../types/container/TObfuscationResultFactory';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IObfuscationResult } from '../interfaces/IObfuscationResult';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { ISourceMapCorrector } from '../interfaces/source-map/ISourceMapCorrector';\n\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\n\n@injectable()\nexport class SourceMapCorrector implements ISourceMapCorrector {\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {TObfuscationResultFactory}\n     */\n    private readonly obfuscationResultFactory: TObfuscationResultFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param {TObfuscationResultFactory} obfuscationResultFactory\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscationResult) obfuscationResultFactory: TObfuscationResultFactory,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.obfuscationResultFactory = obfuscationResultFactory;\n        this.cryptUtils = cryptUtils;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} obfuscatedCode\n     * @param {string} sourceMap\n     * @returns {IObfuscationResult}\n     */\n    public correct (obfuscatedCode: string, sourceMap: string): IObfuscationResult {\n        return this.obfuscationResultFactory(\n            this.correctObfuscatedCode(obfuscatedCode, sourceMap),\n            sourceMap\n        );\n    }\n\n    /**\n     * @param {string} obfuscatedCode\n     * @param {string} sourceMap\n     * @returns {string}\n     */\n    private correctObfuscatedCode (obfuscatedCode: string, sourceMap: string): string {\n        if (!sourceMap) {\n            return obfuscatedCode;\n        }\n\n        const sourceMapUrl: string = this.options.sourceMapBaseUrl + this.options.sourceMapFileName;\n\n        let sourceMappingUrl: string = '//# sourceMappingURL=';\n\n        switch (this.options.sourceMapMode) {\n            case SourceMapMode.Inline:\n                sourceMappingUrl += `data:application/json;base64,${this.cryptUtils.btoa(sourceMap)}`;\n\n                break;\n\n            case SourceMapMode.Separate:\n            default:\n                if (!sourceMapUrl) {\n                    return obfuscatedCode;\n                }\n\n                sourceMappingUrl += sourceMapUrl;\n\n                break;\n        }\n\n        return `${obfuscatedCode}\\n${sourceMappingUrl}`;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/source-map/SourceMapCorrector.ts","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeTransformerFactory } from '../types/container/node-transformers/TNodeTransformerFactory';\nimport { TVisitorDirection } from '../types/node-transformers/TVisitorDirection';\nimport { TVisitorFunction } from '../types/node-transformers/TVisitorFunction';\nimport { TVisitorResult } from '../types/node-transformers/TVisitorResult';\n\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { NodeTransformer } from '../enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\nimport { VisitorDirection } from '../enums/node-transformers/VisitorDirection';\n\nimport { NodeGuards } from '../node/NodeGuards';\n\n@injectable()\nexport class TransformersRunner implements ITransformersRunner {\n    /**\n     * @type {TNodeTransformerFactory}\n     */\n    private readonly nodeTransformerFactory: TNodeTransformerFactory;\n\n    /**\n     * @param {TNodeTransformerFactory} nodeTransformerFactory\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeTransformer) nodeTransformerFactory: TNodeTransformerFactory,\n    ) {\n        this.nodeTransformerFactory = nodeTransformerFactory;\n    }\n\n    /**\n     * @param {T} astTree\n     * @param {NodeTransformer[]} nodeTransformers\n     * @param {TransformationStage} transformationStage\n     * @returns {T}\n     */\n    public transform <T extends ESTree.Node = ESTree.Program> (\n        astTree: T,\n        nodeTransformers: NodeTransformer[],\n        transformationStage: TransformationStage\n    ): T {\n        if (!nodeTransformers.length) {\n            return astTree;\n        }\n\n        const enterVisitors: IVisitor[] = [];\n        const leaveVisitors: IVisitor[] = [];\n        const nodeTransformersLength: number = nodeTransformers.length;\n\n        let visitor: IVisitor | null;\n\n        for (let i: number = 0; i < nodeTransformersLength; i++) {\n            visitor = this.nodeTransformerFactory(nodeTransformers[i]).getVisitor(transformationStage);\n\n            if (!visitor) {\n                continue;\n            }\n\n            if (visitor.enter) {\n                enterVisitors.push({ enter: visitor.enter });\n            }\n\n            if (visitor.leave) {\n                leaveVisitors.push({ leave: visitor.leave });\n            }\n        }\n\n        if (!enterVisitors.length && !leaveVisitors.length) {\n            return astTree;\n        }\n\n        estraverse.replace(astTree, {\n            enter: this.mergeVisitorsForDirection(enterVisitors, VisitorDirection.Enter),\n            leave: this.mergeVisitorsForDirection(leaveVisitors, VisitorDirection.Leave)\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {IVisitor[]} visitors\n     * @param {TVisitorDirection} direction\n     * @returns {TVisitorFunction}\n     */\n    private mergeVisitorsForDirection (visitors: IVisitor[], direction: TVisitorDirection): TVisitorFunction {\n        const visitorsLength: number = visitors.length;\n\n        if (!visitorsLength) {\n            return (node: ESTree.Node, parentNode: ESTree.Node | null) => node;\n        }\n\n        return (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n            if (node.ignoredNode) {\n                return estraverse.VisitorOption.Skip;\n            }\n\n            for (let i: number = 0; i < visitorsLength; i++) {\n                const visitorFunction: TVisitorFunction | undefined = visitors[i][direction];\n\n                if (!visitorFunction) {\n                    continue;\n                }\n\n                const visitorResult: TVisitorResult = visitorFunction(node, parentNode);\n\n                if (!visitorResult || !NodeGuards.isNode(visitorResult)) {\n                    continue;\n                }\n\n                node = visitorResult;\n            }\n\n            return node;\n        };\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/node-transformers/TransformersRunner.ts","export enum VisitorDirection {\n    Enter = 'enter',\n    Leave = 'leave'\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/enums/node-transformers/VisitorDirection.ts","module.exports = require(\"commander\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"commander\"\n// module id = 181\n// module chunks = 0","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\n/**\n * @param {string} value\n * @returns {string[]}\n */\nexport const ArraySanitizer: TCLISanitizer <string[]> = (value: string): string[] => {\n    if (/,$/.test(value)) {\n        throw new SyntaxError(`Multiple <list> values should be wrapped inside quotes: --option-name 'value1, value2'`);\n    }\n\n    return value.split(',').map((string: string) => string.trim());\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/cli/sanitizers/ArraySanitizer.ts","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nexport const BooleanSanitizer: TCLISanitizer <boolean> = (value: string): boolean => {\n    return value === 'true' || value === '1';\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/cli/sanitizers/BooleanSanitizer.ts","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const IdentifierNamesGeneratorSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectIdentifierNamesGenerator: boolean = Object\n        .keys(IdentifierNamesGenerator)\n        .some((key: any): boolean => {\n            return IdentifierNamesGenerator[key] === value;\n        });\n\n    if (!isCorrectIdentifierNamesGenerator) {\n        throw new ReferenceError('Invalid value of `--identifier-names-generator` option');\n    }\n\n    return value;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/cli/sanitizers/IdentifierNamesGeneratorSanitizer.ts","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const ObfuscationTargetSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectTarget: boolean = Object\n        .keys(ObfuscationTarget)\n        .some((key: any): boolean => {\n            return ObfuscationTarget[key] === value;\n        });\n\n    if (!isCorrectTarget) {\n        throw new ReferenceError('Invalid value of `--target` option');\n    }\n\n    return value;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/cli/sanitizers/ObfuscatingTargetSanitizer.ts","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const SourceMapModeSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectSourceMapMode: boolean = Object\n        .keys(SourceMapMode)\n        .some((key: any): boolean => {\n            return SourceMapMode[key] === value;\n        });\n\n    if (!isCorrectSourceMapMode) {\n        throw new ReferenceError('Invalid value of `--source-map-mode` option');\n    }\n\n    return value;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/cli/sanitizers/SourceMapModeSanitizer.ts","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\nimport { TStringArrayEncoding } from '../../types/options/TStringArrayEncoding';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\n/**\n * @param {string} value\n * @returns {TStringArrayEncoding}\n */\nexport const StringArrayEncodingSanitizer: TCLISanitizer <TStringArrayEncoding> = (value: string): TStringArrayEncoding => {\n    switch (value) {\n        case 'true':\n        case '1':\n        case StringArrayEncoding.Base64:\n            return true;\n\n        case StringArrayEncoding.Rc4:\n            return StringArrayEncoding.Rc4;\n\n        default:\n            return false;\n    }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/cli/sanitizers/StringArrayEncodingSanitizer.ts","import * as fs from 'fs';\nimport * as mkdirp from 'mkdirp';\nimport * as path from 'path';\n\nimport { TObject } from '../../types/TObject';\n\nimport { JavaScriptObfuscatorCLI } from '../JavaScriptObfuscatorCLI';\n\nexport class CLIUtils {\n    /**\n     * @param {string} inputPath\n     * @returns {string}\n     */\n    public static getOutputCodePath (inputPath: string): string {\n        return path\n            .normalize(inputPath)\n            .split('.')\n            .map((value: string, index: number) => {\n                return index === 0 ? `${value}${JavaScriptObfuscatorCLI.obfuscatedFilePrefix}` : value;\n            })\n            .join('.');\n    }\n\n    /**\n     * @param {string} outputCodePath\n     * @param {string} sourceMapFileName\n     * @returns {string}\n     */\n    public static getOutputSourceMapPath (outputCodePath: string, sourceMapFileName: string = ''): string {\n        if (sourceMapFileName) {\n            outputCodePath = `${outputCodePath.substring(\n                0, outputCodePath.lastIndexOf('/')\n            )}/${sourceMapFileName}`;\n        }\n\n        if (!/\\.js\\.map$/.test(outputCodePath)) {\n            outputCodePath = `${outputCodePath.split('.')[0]}.js.map`;\n        } else if (/\\.js$/.test(outputCodePath)) {\n            outputCodePath += '.map';\n        }\n\n        return outputCodePath;\n    }\n\n    /**\n     * @param {string} configPath\n     * @returns {TObject}\n     */\n    public static getUserConfig (configPath: string): TObject {\n        let config: Object;\n\n        try {\n            config = require(configPath);\n        } catch (e) {\n            try {\n                config = __non_webpack_require__(configPath);\n            } catch (e) {\n                throw new ReferenceError('Given config path must be a valid `.js` or `.json` file path');\n            }\n        }\n\n        return config;\n    }\n\n    /**\n     * @param {string} outputPath\n     * @param {string} data\n     */\n    public static writeFile (outputPath: string, data: string): void {\n        mkdirp.sync(path.dirname(outputPath));\n\n        fs.writeFileSync(outputPath, data, {\n            encoding: JavaScriptObfuscatorCLI.encoding\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/cli/utils/CLIUtils.ts","module.exports = require(\"mkdirp\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"mkdirp\"\n// module id = 189\n// module chunks = 0","function webpackEmptyContext(req) {\n\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 190;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/cli/utils\n// module id = 190\n// module chunks = 0","import * as fs from 'fs';\nimport * as path from 'path';\n\nimport { TSourceCodeData } from '../../types/cli/TSourceCodeData';\n\nimport { IFileData } from '../../interfaces/cli/IFileData';\n\nimport { JavaScriptObfuscatorCLI } from '../JavaScriptObfuscatorCLI';\n\nexport class SourceCodeReader {\n    /**\n     * @param {string} inputPath\n     * @returns {TSourceCodeData}\n     */\n    public static readSourceCode (inputPath: string): TSourceCodeData {\n        if (SourceCodeReader.isFilePath(inputPath)) {\n            return SourceCodeReader.readFile(inputPath);\n        }\n\n        if (SourceCodeReader.isDirectoryPath(inputPath)) {\n            return SourceCodeReader.readDirectoryRecursive(inputPath);\n        }\n\n        throw new ReferenceError(`Given input path must be a valid source code file or directory path`);\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private static isDirectoryPath (filePath: string): boolean {\n        try {\n            return fs.statSync(filePath).isDirectory();\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private static isFilePath (filePath: string): boolean {\n        try {\n            return fs.statSync(filePath).isFile();\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param {string} directoryPath\n     * @param {IFileData[]} fileData\n     * @returns {IFileData[]}\n     */\n    private static readDirectoryRecursive (directoryPath: string, fileData: IFileData[] = []): IFileData[] {\n        fs.readdirSync(directoryPath, JavaScriptObfuscatorCLI.encoding)\n            .forEach((fileName: string) => {\n                const filePath: string = `${directoryPath}/${fileName}`;\n\n                if (SourceCodeReader.isDirectoryPath(filePath)) {\n                    fileData.push(\n                        ...SourceCodeReader.readDirectoryRecursive(filePath)\n                    );\n                } else if (SourceCodeReader.isFilePath(filePath) && SourceCodeReader.isValidFile(fileName)) {\n                    const content: string = fs.readFileSync(filePath, JavaScriptObfuscatorCLI.encoding);\n\n                    fileData.push({ filePath, content });\n                }\n            });\n\n        return fileData;\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {string}\n     */\n    private static readFile (filePath: string): string {\n        if (!SourceCodeReader.isValidFile(filePath)) {\n            throw new ReferenceError(`Input file must have .js extension`);\n        }\n\n        return fs.readFileSync(filePath, JavaScriptObfuscatorCLI.encoding);\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private static isValidFile (filePath: string): boolean {\n        return JavaScriptObfuscatorCLI.availableInputExtensions.includes(path.extname(filePath))\n            && !filePath.includes(JavaScriptObfuscatorCLI.obfuscatedFilePrefix);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/cli/utils/SourceCodeReader.ts"],"sourceRoot":""}